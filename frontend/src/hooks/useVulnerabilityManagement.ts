/**
 * @fileoverview Custom React hook for VulnerabilityManagement feature. Provides state management and operations for VulnerabilityManagement.
 * 
 * @module hooks/useVulnerabilityManagement
 */

import { useState, useCallback } from 'react';
import { vulnerabilityService } from '@/services/vulnerabilityService';
import type { Vulnerability, FilterOptions, PaginatedResponse, ApiResponse } from '@/types';

/**
 * Custom hook for vulnerability management queries
 */
export function useVulnerabilityQuery() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const getVulnerabilities = useCallback(async (filters?: FilterOptions): Promise<PaginatedResponse<Vulnerability> | null> => {
    try {
      setLoading(true);
      setError(null);
      const response = await vulnerabilityService.getVulnerabilities(filters);
      return response;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to fetch vulnerabilities';
      setError(message);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const getVulnerability = useCallback(async (id: string): Promise<Vulnerability | null> => {
    try {
      setLoading(true);
      setError(null);
      const response = await vulnerabilityService.getVulnerability(id);
      return response.data || null;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to fetch vulnerability';
      setError(message);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const getScanResults = useCallback(async (scanId: string): Promise<ApiResponse<unknown> | null> => {
    try {
      setLoading(true);
      setError(null);
      const response = await vulnerabilityService.getScanResults(scanId);
      return response;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to fetch scan results';
      setError(message);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    getVulnerabilities,
    getVulnerability,
    getScanResults,
    loading,
    error,
  };
}

/**
 * Custom hook for vulnerability management mutations
 */
export function useVulnerabilityMutation() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createVulnerability = useCallback(async (data: Partial<Vulnerability>): Promise<Vulnerability | null> => {
    try {
      setLoading(true);
      setError(null);
      const response = await vulnerabilityService.createVulnerability(data);
      return response.data || null;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to create vulnerability';
      setError(message);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const updateVulnerability = useCallback(async (id: string, data: Partial<Vulnerability>): Promise<Vulnerability | null> => {
    try {
      setLoading(true);
      setError(null);
      const response = await vulnerabilityService.updateVulnerability(id, data);
      return response.data || null;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to update vulnerability';
      setError(message);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const deleteVulnerability = useCallback(async (id: string): Promise<boolean> => {
    try {
      setLoading(true);
      setError(null);
      await vulnerabilityService.deleteVulnerability(id);
      return true;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to delete vulnerability';
      setError(message);
      return false;
    } finally {
      setLoading(false);
    }
  }, []);

  const updateStatus = useCallback(async (id: string, status: string): Promise<Vulnerability | null> => {
    try {
      setLoading(true);
      setError(null);
      const response = await vulnerabilityService.updateStatus(id, status);
      return response.data || null;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to update vulnerability status';
      setError(message);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const runScan = useCallback(async (targets?: string[]): Promise<ApiResponse<unknown> | null> => {
    try {
      setLoading(true);
      setError(null);
      const response = await vulnerabilityService.runScan(targets);
      return response;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to run vulnerability scan';
      setError(message);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    createVulnerability,
    updateVulnerability,
    deleteVulnerability,
    updateStatus,
    runScan,
    loading,
    error,
  };
}

/**
 * Custom hook for composite vulnerability management operations
 */
export function useVulnerabilityComposite() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const scanAndRefresh = useCallback(async (
    targets?: string[],
    filters?: FilterOptions
  ): Promise<PaginatedResponse<Vulnerability> | null> => {
    try {
      setLoading(true);
      setError(null);
      
      // Run scan
      await vulnerabilityService.runScan(targets);
      
      // Fetch updated vulnerabilities
      const response = await vulnerabilityService.getVulnerabilities(filters);
      return response;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to scan and refresh vulnerabilities';
      setError(message);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  const patchVulnerability = useCallback(async (id: string): Promise<Vulnerability | null> => {
    try {
      setLoading(true);
      setError(null);
      
      // Update status to patched
      const response = await vulnerabilityService.updateStatus(id, 'patched');
      return response.data || null;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to patch vulnerability';
      setError(message);
      return null;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    scanAndRefresh,
    patchVulnerability,
    loading,
    error,
  };
}

/**
 * Main hook that combines all vulnerability management operations
 */
export function useVulnerabilityManagement() {
  const queries = useVulnerabilityQuery();
  const mutations = useVulnerabilityMutation();
  const composites = useVulnerabilityComposite();

  return {
    queries,
    mutations,
    composites,
  };
}
