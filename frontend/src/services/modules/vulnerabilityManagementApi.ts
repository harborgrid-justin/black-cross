/**
 * @fileoverview API module for vulnerabilityManagement. Provides type-safe API methods and request/response handling.
 * 
 * @module services/modules/vulnerabilityManagementApi
 */

/**
 * WF-COMP-006 | vulnerabilityManagementApi.ts - Vulnerability Management API service module
 * Purpose: Vulnerability Management domain API operations with type safety and validation
 * Upstream: ../config/apiConfig, ../utils/apiUtils, ../types | Dependencies: axios, zod
 * Downstream: Components, Redux stores | Called by: Vulnerability components and stores
 * Related: Vulnerability types, vulnerability Redux slice
 * Exports: vulnerabilityManagementApi instance, types | Key Features: CRUD operations, validation, error handling
 * Last Updated: 2025-10-22 | File Type: .ts
 * Critical Path: Component request → API call → Backend → Response transformation → Component update
 * LLM Context: Domain-specific API service with comprehensive type safety and validation
 */

import { apiInstance } from '../config/apiConfig';
import type { 
  ApiResponse, 
  PaginatedResponse} from '../utils/apiUtils';
import { 
  buildUrlParams,
  handleApiError,
  extractApiData,
  withRetry
} from '../utils/apiUtils';
import { z } from 'zod';
import type { Vulnerability } from '../../types';

// ==========================================
// INTERFACES & TYPES
// ==========================================

export interface VulnerabilityFilters {
  search?: string;
  status?: ('open' | 'patched' | 'mitigated' | 'accepted')[];
  severity?: ('critical' | 'high' | 'medium' | 'low')[];
  cveId?: string;
  affectedAsset?: string;
  patchAvailable?: boolean;
  dateFrom?: string;
  dateTo?: string;
  page?: number;
  limit?: number;
  perPage?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface CreateVulnerabilityData {
  cveId: string;
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  cvssScore: number;
  affectedAssets?: string[];
  patchAvailable?: boolean;
}

export interface UpdateVulnerabilityData {
  title?: string;
  description?: string;
  severity?: 'critical' | 'high' | 'medium' | 'low';
  cvssScore?: number;
  status?: 'open' | 'patched' | 'mitigated' | 'accepted';
  affectedAssets?: string[];
  patchAvailable?: boolean;
}

export interface VulnerabilityStatistics {
  total: number;
  open: number;
  patched: number;
  mitigated: number;
  accepted: number;
  bySeverity: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  withPatch: number;
  withoutPatch: number;
  avgCvssScore: number;
}

export interface ScanTarget {
  type: 'host' | 'network' | 'application';
  target: string;
  options?: Record<string, unknown>;
}

export interface ScanResult {
  id: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  startedAt: string;
  completedAt?: string;
  vulnerabilitiesFound: number;
  targets: string[];
}

export interface VulnerabilityManagementApi {
  // Basic CRUD operations
  getAll(filters?: VulnerabilityFilters): Promise<PaginatedResponse<Vulnerability>>;
  getById(id: string): Promise<Vulnerability>;
  create(data: CreateVulnerabilityData): Promise<Vulnerability>;
  update(id: string, data: UpdateVulnerabilityData): Promise<Vulnerability>;
  delete(id: string): Promise<void>;
  
  // Status management
  updateStatus(id: string, status: string): Promise<Vulnerability>;
  
  // Scanning operations
  runScan(targets: ScanTarget[]): Promise<ScanResult>;
  getScanResults(scanId: string): Promise<ScanResult>;
  getScanHistory(filters?: { limit?: number }): Promise<ScanResult[]>;
  
  // Statistics and reporting
  getStatistics(filters?: VulnerabilityFilters): Promise<VulnerabilityStatistics>;
  
  // Search
  search(query: string, filters?: VulnerabilityFilters): Promise<Vulnerability[]>;
}

// ==========================================
// VALIDATION SCHEMAS
// ==========================================

const ID_REGEX = /^[a-zA-Z0-9-_]{1,50}$/;
const CVE_REGEX = /^CVE-\d{4}-\d{4,}$/;

const createVulnerabilitySchema = z.object({
  cveId: z
    .string()
    .regex(CVE_REGEX, 'Invalid CVE ID format (e.g., CVE-2024-1234)')
    .max(50),
    
  title: z
    .string()
    .min(1, 'Title is required')
    .max(200, 'Title cannot exceed 200 characters')
    .trim(),
    
  description: z
    .string()
    .min(1, 'Description is required')
    .max(5000, 'Description cannot exceed 5000 characters'),
    
  severity: z
    .enum(['critical', 'high', 'medium', 'low']),
    
  cvssScore: z
    .number()
    .min(0, 'CVSS score must be between 0 and 10')
    .max(10, 'CVSS score must be between 0 and 10'),
    
  affectedAssets: z
    .array(z.string().max(200))
    .max(100)
    .optional(),
    
  patchAvailable: z
    .boolean()
    .optional(),
}).strict();

const updateVulnerabilitySchema = createVulnerabilitySchema.partial().extend({
  status: z.enum(['open', 'patched', 'mitigated', 'accepted']).optional(),
});

const vulnerabilityFiltersSchema = z.object({
  search: z.string().max(200).optional(),
  status: z.array(z.enum(['open', 'patched', 'mitigated', 'accepted'])).optional(),
  severity: z.array(z.enum(['critical', 'high', 'medium', 'low'])).optional(),
  cveId: z.string().max(50).optional(),
  affectedAsset: z.string().max(200).optional(),
  patchAvailable: z.boolean().optional(),
  dateFrom: z.string().datetime().optional(),
  dateTo: z.string().datetime().optional(),
  page: z.number().int().min(1).optional(),
  limit: z.number().int().min(1).max(100).optional(),
  perPage: z.number().int().min(1).max(100).optional(),
  sortBy: z.string().max(50).optional(),
  sortOrder: z.enum(['asc', 'desc']).optional(),
}).strict();

const scanTargetSchema = z.object({
  type: z.enum(['host', 'network', 'application']),
  target: z.string().min(1).max(500),
  options: z.record(z.unknown()).optional(),
});

// ==========================================
// API IMPLEMENTATION CLASS
// ==========================================

class VulnerabilityManagementApiImpl implements VulnerabilityManagementApi {
  private readonly baseEndpoint = '/vulnerability-management';

  async getAll(filters?: VulnerabilityFilters): Promise<PaginatedResponse<Vulnerability>> {
    try {
      const validatedFilters = filters ? vulnerabilityFiltersSchema.parse(filters) : {};
      const params = buildUrlParams(validatedFilters);
      const url = `${this.baseEndpoint}${params.toString() ? `?${params.toString()}` : ''}`;
      
      const response = await withRetry(() => apiInstance.get(url), {
        maxRetries: 3,
        backoffMs: 1000
      });
      
      return response.data as PaginatedResponse<Vulnerability>;
    } catch (error) {
      throw handleApiError(error);
    }
  }

  async getById(id: string): Promise<Vulnerability> {
    try {
      if (!ID_REGEX.test(id)) {
        throw new Error('Invalid ID format');
      }
      
      const response = await apiInstance.get<ApiResponse<Vulnerability>>(`${this.baseEndpoint}/${id}`);
      return extractApiData<Vulnerability>(response);
    } catch (error) {
      throw handleApiError(error);
    }
  }

  async create(data: CreateVulnerabilityData): Promise<Vulnerability> {
    try {
      const validatedData = createVulnerabilitySchema.parse(data);
      
      const response = await apiInstance.post<ApiResponse<Vulnerability>>(this.baseEndpoint, validatedData);
      return extractApiData<Vulnerability>(response);
    } catch (error) {
      throw handleApiError(error);
    }
  }

  async update(id: string, data: UpdateVulnerabilityData): Promise<Vulnerability> {
    try {
      if (!ID_REGEX.test(id)) {
        throw new Error('Invalid ID format');
      }
      
      const validatedData = updateVulnerabilitySchema.parse(data);
      
      const response = await apiInstance.put<ApiResponse<Vulnerability>>(`${this.baseEndpoint}/${id}`, validatedData);
      return extractApiData<Vulnerability>(response);
    } catch (error) {
      throw handleApiError(error);
    }
  }

  async delete(id: string): Promise<void> {
    try {
      if (!ID_REGEX.test(id)) {
        throw new Error('Invalid ID format');
      }
      
      await apiInstance.delete(`${this.baseEndpoint}/${id}`);
    } catch (error) {
      throw handleApiError(error);
    }
  }

  async updateStatus(id: string, status: string): Promise<Vulnerability> {
    try {
      if (!ID_REGEX.test(id)) {
        throw new Error('Invalid ID format');
      }
      
      const response = await apiInstance.patch<ApiResponse<Vulnerability>>(
        `${this.baseEndpoint}/${id}/status`,
        { status }
      );
      return extractApiData<Vulnerability>(response);
    } catch (error) {
      throw handleApiError(error);
    }
  }

  async runScan(targets: ScanTarget[]): Promise<ScanResult> {
    try {
      const validatedTargets = targets.map(target => scanTargetSchema.parse(target));
      
      const response = await apiInstance.post<ApiResponse<ScanResult>>(
        `${this.baseEndpoint}/scan`,
        { targets: validatedTargets }
      );
      return extractApiData<ScanResult>(response);
    } catch (error) {
      throw handleApiError(error);
    }
  }

  async getScanResults(scanId: string): Promise<ScanResult> {
    try {
      if (!ID_REGEX.test(scanId)) {
        throw new Error('Invalid scan ID format');
      }
      
      const response = await apiInstance.get<ApiResponse<ScanResult>>(
        `${this.baseEndpoint}/scan/${scanId}`
      );
      return extractApiData<ScanResult>(response);
    } catch (error) {
      throw handleApiError(error);
    }
  }

  async getScanHistory(filters?: { limit?: number }): Promise<ScanResult[]> {
    try {
      const params = filters ? buildUrlParams(filters) : '';
      const url = `${this.baseEndpoint}/scan/history${params ? `?${params.toString()}` : ''}`;
      
      const response = await apiInstance.get<ApiResponse<ScanResult[]>>(url);
      return extractApiData<ScanResult[]>(response);
    } catch (error) {
      throw handleApiError(error);
    }
  }

  async getStatistics(filters?: VulnerabilityFilters): Promise<VulnerabilityStatistics> {
    try {
      const validatedFilters = filters ? vulnerabilityFiltersSchema.parse(filters) : {};
      const params = buildUrlParams(validatedFilters);
      const url = `${this.baseEndpoint}/stats${params.toString() ? `?${params.toString()}` : ''}`;
      
      const response = await apiInstance.get<ApiResponse<VulnerabilityStatistics>>(url);
      return extractApiData<VulnerabilityStatistics>(response);
    } catch (error) {
      throw handleApiError(error);
    }
  }

  async search(query: string, filters?: VulnerabilityFilters): Promise<Vulnerability[]> {
    try {
      const validatedFilters = filters ? vulnerabilityFiltersSchema.parse(filters) : {};
      const searchParams = { ...validatedFilters, q: query };
      const params = buildUrlParams(searchParams);
      
      const response = await apiInstance.get<ApiResponse<Vulnerability[]>>(
        `${this.baseEndpoint}/search?${params.toString()}`
      );
      return extractApiData<Vulnerability[]>(response);
    } catch (error) {
      throw handleApiError(error);
    }
  }
}

// ==========================================
// SINGLETON EXPORT
// ==========================================

export const vulnerabilityManagementApi: VulnerabilityManagementApi = new VulnerabilityManagementApiImpl();
