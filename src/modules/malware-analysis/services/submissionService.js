/**
 * Malware Submission Service
 * Handles submission, queue management, and duplicate detection
 */

const MalwareSample = require('../models/MalwareSample');
const { calculateAllHashes } = require('../utils/hashUtils');
const logger = require('../utils/logger');

class SubmissionService {
  /**
   * Submit a new malware sample
   */
  async submitSample(fileData, metadata) {
    try {
      // Calculate hashes
      const hashes = calculateAllHashes(fileData);

      // Check for duplicates
      const duplicate = await this.checkDuplicate(hashes.sha256);
      if (duplicate) {
        logger.info(`Duplicate sample detected: ${hashes.sha256}`);
        return {
          duplicate: true,
          existing_sample: duplicate,
          message: 'Sample already exists in the database',
        };
      }

      // Create new sample record
      const sample = new MalwareSample({
        file_name: metadata.file_name,
        file_size: fileData.length,
        file_type: metadata.file_type || 'unknown',
        md5: hashes.md5,
        sha1: hashes.sha1,
        sha256: hashes.sha256,
        submitted_by: metadata.submitted_by || 'anonymous',
        priority: metadata.priority || 'medium',
        status: 'queued',
        tags: metadata.tags || [],
        notes: metadata.notes,
      });

      await sample.save();

      logger.info(`Sample submitted successfully: ${sample.id}`);

      return {
        duplicate: false,
        sample,
        message: 'Sample submitted successfully',
      };
    } catch (error) {
      logger.error('Error submitting sample:', error);
      throw error;
    }
  }

  /**
   * Check for duplicate samples by hash
   */
  async checkDuplicate(sha256) {
    try {
      const existing = await MalwareSample.findOne({ sha256 });
      return existing;
    } catch (error) {
      logger.error('Error checking duplicate:', error);
      throw error;
    }
  }

  /**
   * Get all submissions with pagination
   */
  async getSubmissions(filters = {}, page = 1, limit = 50) {
    try {
      const query = {};

      if (filters.status) {
        query.status = filters.status;
      }

      if (filters.priority) {
        query.priority = filters.priority;
      }

      if (filters.submitted_by) {
        query.submitted_by = filters.submitted_by;
      }

      if (filters.classification) {
        query.classification = filters.classification;
      }

      if (filters.malware_family) {
        query.malware_family = filters.malware_family;
      }

      const skip = (page - 1) * limit;

      const [samples, total] = await Promise.all([
        MalwareSample.find(query)
          .sort({ submitted_at: -1 })
          .skip(skip)
          .limit(limit)
          .lean(),
        MalwareSample.countDocuments(query),
      ]);

      return {
        samples,
        pagination: {
          page,
          limit,
          total,
          total_pages: Math.ceil(total / limit),
        },
      };
    } catch (error) {
      logger.error('Error getting submissions:', error);
      throw error;
    }
  }

  /**
   * Get submission by ID
   */
  async getSubmissionById(id) {
    try {
      const sample = await MalwareSample.findOne({ id });
      if (!sample) {
        throw new Error('Sample not found');
      }
      return sample;
    } catch (error) {
      logger.error('Error getting submission by ID:', error);
      throw error;
    }
  }

  /**
   * Update submission status
   */
  async updateStatus(id, status) {
    try {
      const sample = await MalwareSample.findOneAndUpdate(
        { id },
        { status, updated_at: Date.now() },
        { new: true },
      );

      if (!sample) {
        throw new Error('Sample not found');
      }

      logger.info(`Sample status updated: ${id} -> ${status}`);
      return sample;
    } catch (error) {
      logger.error('Error updating status:', error);
      throw error;
    }
  }

  /**
   * Get queue statistics
   */
  async getQueueStats() {
    try {
      const [total, pending, queued, analyzing, completed, failed] = await Promise.all([
        MalwareSample.countDocuments(),
        MalwareSample.countDocuments({ status: 'pending' }),
        MalwareSample.countDocuments({ status: 'queued' }),
        MalwareSample.countDocuments({ status: 'analyzing' }),
        MalwareSample.countDocuments({ status: 'completed' }),
        MalwareSample.countDocuments({ status: 'failed' }),
      ]);

      return {
        total,
        pending,
        queued,
        analyzing,
        completed,
        failed,
        active: pending + queued + analyzing,
      };
    } catch (error) {
      logger.error('Error getting queue stats:', error);
      throw error;
    }
  }

  /**
   * Bulk submission support
   */
  async bulkSubmit(samples) {
    try {
      const results = [];

      const promises = samples.map(async (sample) => {
        try {
          const result = await this.submitSample(sample.fileData, sample.metadata);
          return { success: true, result };
        } catch (error) {
          return { success: false, error: error.message };
        }
      });

      const bulkResults = await Promise.all(promises);

      return {
        total: samples.length,
        successful: bulkResults.filter((r) => r.success).length,
        failed: bulkResults.filter((r) => !r.success).length,
        results: bulkResults,
      };
    } catch (error) {
      logger.error('Error in bulk submission:', error);
      throw error;
    }
  }
}

module.exports = new SubmissionService();
