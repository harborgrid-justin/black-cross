/**
 * IOC (Indicator of Compromise) Extraction Service
 */

const MalwareSample = require('../models/MalwareSample');
const patternExtractor = require('../utils/patternExtractor');
const logger = require('../utils/logger');

class IOCExtractionService {
  /**
   * Extract IOCs from a malware sample
   */
  async extractIOCs(sampleId) {
    try {
      const sample = await MalwareSample.findOne({ id: sampleId });
      if (!sample) {
        throw new Error('Sample not found');
      }

      logger.info(`Extracting IOCs from sample: ${sampleId}`);

      const iocs = [];

      // Extract from static analysis strings
      if (sample.static_analysis?.strings) {
        const stringData = sample.static_analysis.strings.join(' ');
        const extractedIOCs = patternExtractor.extractAllIOCs(stringData);

        // Add IP addresses
        extractedIOCs.ips.forEach((ip) => {
          iocs.push({
            type: 'ip',
            value: ip,
            context: 'Extracted from static strings',
            confidence: 70,
          });
        });

        // Add domains
        extractedIOCs.domains.forEach((domain) => {
          iocs.push({
            type: 'domain',
            value: domain,
            context: 'Extracted from static strings',
            confidence: 70,
          });
        });

        // Add URLs
        extractedIOCs.urls.forEach((url) => {
          iocs.push({
            type: 'url',
            value: url,
            context: 'Extracted from static strings',
            confidence: 80,
          });
        });

        // Add emails
        extractedIOCs.emails.forEach((email) => {
          iocs.push({
            type: 'email',
            value: email,
            context: 'Extracted from static strings',
            confidence: 60,
          });
        });

        // Add cryptocurrency addresses
        Object.entries(extractedIOCs.cryptocurrency).forEach(([type, addresses]) => {
          addresses.forEach((address) => {
            iocs.push({
              type: 'cryptocurrency',
              value: `${type}:${address}`,
              context: 'Extracted from static strings',
              confidence: 85,
            });
          });
        });

        // Add registry keys
        extractedIOCs.registry_keys.forEach((key) => {
          iocs.push({
            type: 'registry',
            value: key,
            context: 'Extracted from static strings',
            confidence: 75,
          });
        });
      }

      // Extract from dynamic analysis network activity
      if (sample.dynamic_analysis?.network_activity) {
        sample.dynamic_analysis.network_activity.forEach((activity) => {
          if (activity.destination && activity.destination !== '0.0.0.0') {
            iocs.push({
              type: 'ip',
              value: activity.destination,
              context: `Network communication observed on port ${activity.port}`,
              confidence: 95,
            });
          }
        });
      }

      // Extract from behavioral analysis
      if (sample.behavioral_analysis?.registry_operations) {
        sample.behavioral_analysis.registry_operations.forEach((op) => {
          iocs.push({
            type: 'registry',
            value: op.key,
            context: `Registry ${op.operation} operation`,
            confidence: 90,
          });
        });
      }

      if (sample.behavioral_analysis?.dropped_files) {
        sample.behavioral_analysis.dropped_files.forEach((file) => {
          if (file.hash) {
            iocs.push({
              type: 'hash',
              value: file.hash,
              context: `Dropped file: ${file.file_name}`,
              confidence: 100,
            });
          }

          iocs.push({
            type: 'filename',
            value: file.file_name,
            context: 'File dropped during execution',
            confidence: 95,
          });
        });
      }

      if (sample.behavioral_analysis?.mutexes_created) {
        sample.behavioral_analysis.mutexes_created.forEach((mutex) => {
          iocs.push({
            type: 'mutex',
            value: mutex,
            context: 'Mutex created during execution',
            confidence: 100,
          });
        });
      }

      // Add sample hashes as IOCs
      iocs.push(
        {
          type: 'hash',
          value: sample.md5,
          context: 'Sample MD5 hash',
          confidence: 100,
        },
        {
          type: 'hash',
          value: sample.sha1,
          context: 'Sample SHA1 hash',
          confidence: 100,
        },
        {
          type: 'hash',
          value: sample.sha256,
          context: 'Sample SHA256 hash',
          confidence: 100,
        },
      );

      // Remove duplicates
      const uniqueIOCs = this.deduplicateIOCs(iocs);

      // Update sample with extracted IOCs
      sample.iocs = uniqueIOCs;
      await sample.save();

      logger.info(`Extracted ${uniqueIOCs.length} IOCs from sample: ${sampleId}`);

      return {
        sample_id: sampleId,
        iocs: uniqueIOCs,
        count: uniqueIOCs.length,
        types: this.getIOCTypeCounts(uniqueIOCs),
      };
    } catch (error) {
      logger.error('Error extracting IOCs:', error);
      throw error;
    }
  }

  /**
   * Deduplicate IOCs
   */
  deduplicateIOCs(iocs) {
    const seen = new Set();
    const unique = [];

    iocs.forEach((ioc) => {
      const key = `${ioc.type}:${ioc.value}`;
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(ioc);
      }
    });

    return unique;
  }

  /**
   * Get IOC type counts
   */
  getIOCTypeCounts(iocs) {
    const counts = {};

    iocs.forEach((ioc) => {
      counts[ioc.type] = (counts[ioc.type] || 0) + 1;
    });

    return counts;
  }

  /**
   * Get IOCs for a sample
   */
  async getIOCs(sampleId, filters = {}) {
    try {
      const sample = await MalwareSample.findOne({ id: sampleId });
      if (!sample) {
        throw new Error('Sample not found');
      }

      let iocs = sample.iocs || [];

      // Apply filters
      if (filters.type) {
        iocs = iocs.filter((ioc) => ioc.type === filters.type);
      }

      if (filters.min_confidence) {
        iocs = iocs.filter((ioc) => ioc.confidence >= filters.min_confidence);
      }

      return {
        sample_id: sampleId,
        iocs,
        count: iocs.length,
        types: this.getIOCTypeCounts(iocs),
      };
    } catch (error) {
      logger.error('Error getting IOCs:', error);
      throw error;
    }
  }

  /**
   * Export IOCs in various formats
   */
  async exportIOCs(sampleId, format = 'json') {
    try {
      const result = await this.getIOCs(sampleId);

      switch (format) {
        case 'json':
          return JSON.stringify(result, null, 2);

        case 'csv':
          return this.convertToCSV(result.iocs);

        case 'stix':
          return this.convertToSTIX(result);

        case 'misp':
          return this.convertToMISP(result);

        default:
          throw new Error(`Unsupported format: ${format}`);
      }
    } catch (error) {
      logger.error('Error exporting IOCs:', error);
      throw error;
    }
  }

  /**
   * Convert IOCs to CSV format
   */
  convertToCSV(iocs) {
    const headers = 'Type,Value,Context,Confidence\n';
    const rows = iocs.map((ioc) => `${ioc.type},${ioc.value},"${ioc.context}",${ioc.confidence}`).join('\n');

    return headers + rows;
  }

  /**
   * Convert IOCs to STIX format (simplified)
   */
  convertToSTIX(result) {
    return {
      type: 'bundle',
      id: `bundle--${result.sample_id}`,
      objects: result.iocs.map((ioc, index) => ({
        type: 'indicator',
        id: `indicator--${index}`,
        pattern: `[${ioc.type}:value = '${ioc.value}']`,
        valid_from: new Date().toISOString(),
        labels: ['malicious-activity'],
      })),
    };
  }

  /**
   * Convert IOCs to MISP format (simplified)
   */
  convertToMISP(result) {
    return {
      Event: {
        info: `IOCs from sample ${result.sample_id}`,
        threat_level_id: '1',
        analysis: '2',
        Attribute: result.iocs.map((ioc) => ({
          type: ioc.type,
          value: ioc.value,
          comment: ioc.context,
          to_ids: true,
        })),
      },
    };
  }

  /**
   * Search IOCs across all samples
   */
  async searchIOCs(searchValue, searchType = null) {
    try {
      const query = {
        'iocs.value': new RegExp(searchValue, 'i'),
      };

      if (searchType) {
        query['iocs.type'] = searchType;
      }

      const samples = await MalwareSample.find(query)
        .select('id file_name sha256 iocs malware_family classification')
        .lean();

      const results = samples.map((sample) => ({
        sample_id: sample.id,
        file_name: sample.file_name,
        sha256: sample.sha256,
        malware_family: sample.malware_family,
        classification: sample.classification,
        matching_iocs: sample.iocs.filter((ioc) => ioc.value.toLowerCase().includes(searchValue.toLowerCase())),
      }));

      return {
        search_value: searchValue,
        search_type: searchType,
        matches: results.length,
        results,
      };
    } catch (error) {
      logger.error('Error searching IOCs:', error);
      throw error;
    }
  }
}

module.exports = new IOCExtractionService();
