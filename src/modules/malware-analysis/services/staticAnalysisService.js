/**
 * Static Analysis Service
 * Performs static malware analysis
 */

const MalwareSample = require('../models/MalwareSample');
const logger = require('../utils/logger');

class StaticAnalysisService {
  /**
   * Perform static analysis on a sample
   */
  async analyze(sampleId, fileData) {
    try {
      const sample = await MalwareSample.findOne({ id: sampleId });
      if (!sample) {
        throw new Error('Sample not found');
      }

      logger.info(`Starting static analysis for sample: ${sampleId}`);

      // Perform various static analysis techniques
      const analysis = {
        strings: this.extractStrings(fileData),
        entropy: this.calculateEntropy(fileData),
        pe_headers: this.analyzePEHeaders(fileData),
        imports: this.extractImports(fileData),
        exports: this.extractExports(fileData),
        sections: this.analyzeSections(fileData),
        packer_detected: this.detectPacker(fileData),
        anti_analysis_detected: this.detectAntiAnalysis(fileData),
        obfuscation_detected: this.detectObfuscation(fileData),
      };

      // Update sample with analysis results
      sample.static_analysis = analysis;
      sample.status = 'analyzing';
      await sample.save();

      logger.info(`Static analysis completed for sample: ${sampleId}`);

      return analysis;
    } catch (error) {
      logger.error('Error performing static analysis:', error);
      throw error;
    }
  }

  /**
   * Extract printable strings from binary data
   */
  extractStrings(data, minLength = 4) {
    const strings = [];
    let currentString = '';

    for (let i = 0; i < data.length; i++) {
      const char = data[i];

      // Check if character is printable ASCII
      if (char >= 32 && char <= 126) {
        currentString += String.fromCharCode(char);
      } else if (currentString.length >= minLength) {
        strings.push(currentString);
        currentString = '';
      } else {
        currentString = '';
      }
    }

    // Add last string if it meets length requirement
    if (currentString.length >= minLength) {
      strings.push(currentString);
    }

    // Return unique strings
    return [...new Set(strings)].slice(0, 500); // Limit to 500 strings
  }

  /**
   * Calculate entropy of data (measure of randomness/encryption)
   */
  calculateEntropy(data) {
    if (data.length === 0) return 0;

    const frequencies = new Array(256).fill(0);

    // Count byte frequencies
    for (let i = 0; i < data.length; i++) {
      frequencies[data[i]]++;
    }

    // Calculate entropy
    let entropy = 0;
    for (let i = 0; i < 256; i++) {
      if (frequencies[i] > 0) {
        const probability = frequencies[i] / data.length;
        entropy -= probability * Math.log2(probability);
      }
    }

    return entropy.toFixed(4);
  }

  /**
   * Analyze PE (Portable Executable) headers
   * Simulated - would use a real PE parser in production
   */
  analyzePEHeaders(data) {
    // Check for PE signature
    const isPE = data.length > 2 && data[0] === 0x4D && data[1] === 0x5A; // "MZ"

    if (!isPE) {
      return null;
    }

    // Simulated PE header analysis
    return {
      signature_valid: true,
      machine_type: 'x86',
      timestamp: new Date().toISOString(),
      characteristics: ['EXECUTABLE', 'DLL'],
      subsystem: 'WINDOWS_GUI',
      image_base: '0x00400000',
      entry_point: '0x00001000',
    };
  }

  /**
   * Extract imports from executable
   */
  extractImports(data) {
    // Simulated import extraction
    // In production, would parse import tables
    const commonImports = [
      'kernel32.dll!CreateFileA',
      'kernel32.dll!WriteFile',
      'kernel32.dll!CloseHandle',
      'ws2_32.dll!socket',
      'ws2_32.dll!connect',
      'advapi32.dll!RegOpenKeyExA',
    ];

    return commonImports.slice(0, Math.floor(Math.random() * 6) + 1);
  }

  /**
   * Extract exports from executable
   */
  extractExports(data) {
    // Simulated export extraction
    return [];
  }

  /**
   * Analyze file sections
   */
  analyzeSections(data) {
    // Simulated section analysis
    return [
      {
        name: '.text',
        virtual_size: 0x1000,
        virtual_address: 0x1000,
        characteristics: ['CODE', 'EXECUTABLE', 'READABLE'],
      },
      {
        name: '.data',
        virtual_size: 0x500,
        virtual_address: 0x2000,
        characteristics: ['INITIALIZED_DATA', 'READABLE', 'WRITABLE'],
      },
    ];
  }

  /**
   * Detect if file is packed
   */
  detectPacker(data) {
    const entropy = parseFloat(this.calculateEntropy(data));

    // High entropy often indicates packing/encryption
    if (entropy > 7.0) {
      return true;
    }

    // Check for common packer signatures
    const packerSignatures = [
      Buffer.from('UPX'),
      Buffer.from('MPRESS'),
      Buffer.from('ASPack'),
    ];

    for (const signature of packerSignatures) {
      if (data.includes(signature)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Detect anti-analysis techniques
   */
  detectAntiAnalysis(data) {
    const strings = this.extractStrings(data);

    // Check for common anti-analysis strings
    const antiAnalysisIndicators = [
      'IsDebuggerPresent',
      'CheckRemoteDebuggerPresent',
      'NtQueryInformationProcess',
      'OutputDebugString',
      'VirtualBox',
      'VMware',
      'QEMU',
    ];

    return strings.some((str) => antiAnalysisIndicators.some((indicator) => str.includes(indicator)));
  }

  /**
   * Detect code obfuscation
   */
  detectObfuscation(data) {
    const entropy = parseFloat(this.calculateEntropy(data));
    const strings = this.extractStrings(data);

    // High entropy and few readable strings suggests obfuscation
    return entropy > 6.5 && strings.length < 50;
  }

  /**
   * Get static analysis results for a sample
   */
  async getAnalysis(sampleId) {
    try {
      const sample = await MalwareSample.findOne({ id: sampleId });
      if (!sample) {
        throw new Error('Sample not found');
      }

      if (!sample.static_analysis) {
        throw new Error('Static analysis not yet performed');
      }

      return sample.static_analysis;
    } catch (error) {
      logger.error('Error getting static analysis:', error);
      throw error;
    }
  }
}

module.exports = new StaticAnalysisService();
