/**
 * Malware Family Classification Service
 */

const MalwareSample = require('../models/MalwareSample');
const logger = require('../utils/logger');

class ClassificationService {
  constructor() {
    // Simulated malware family signatures
    this.familySignatures = {
      emotet: {
        patterns: ['emotet', 'epoch', 'banking'],
        behaviors: ['persistence', 'c2_communication', 'credential_theft'],
        ioc_patterns: ['emotet-c2'],
      },
      wannacry: {
        patterns: ['wannacry', 'wcry', 'wncry'],
        behaviors: ['encryption', 'network_propagation'],
        ioc_patterns: ['onion'],
      },
      trickbot: {
        patterns: ['trickbot', 'trickster'],
        behaviors: ['persistence', 'credential_theft', 'lateral_movement'],
        ioc_patterns: ['trickbot-module'],
      },
      ryuk: {
        patterns: ['ryuk', 'hermes'],
        behaviors: ['encryption', 'shadow_copy_deletion'],
        ioc_patterns: ['ryuk-note'],
      },
      zeus: {
        patterns: ['zeus', 'zbot'],
        behaviors: ['keylogging', 'credential_theft', 'c2_communication'],
        ioc_patterns: ['zeus-config'],
      },
    };
  }

  /**
   * Classify a malware sample
   */
  async classify(sampleId) {
    try {
      const sample = await MalwareSample.findOne({ id: sampleId });
      if (!sample) {
        throw new Error('Sample not found');
      }

      logger.info(`Classifying sample: ${sampleId}`);

      // Perform classification using multiple techniques
      const results = {
        signature_based: this.signatureBasedClassification(sample),
        behavior_based: this.behaviorBasedClassification(sample),
        yara_based: this.yaraBasedClassification(sample),
        ml_based: this.mlBasedClassification(sample),
      };

      // Aggregate results
      const classification = this.aggregateResults(results);

      // Update sample with classification
      sample.malware_family = classification.family;
      sample.classification = classification.type;
      sample.threat_level = classification.threat_level;
      sample.confidence_score = classification.confidence;
      await sample.save();

      logger.info(`Sample classified: ${sampleId} -> ${classification.family}`);

      return {
        sample_id: sampleId,
        classification: classification.family,
        type: classification.type,
        threat_level: classification.threat_level,
        confidence: classification.confidence,
        details: results,
      };
    } catch (error) {
      logger.error('Error classifying sample:', error);
      throw error;
    }
  }

  /**
   * Signature-based classification
   */
  signatureBasedClassification(sample) {
    const strings = sample.static_analysis?.strings || [];
    const matches = {};

    // Check each family signature
    Object.entries(this.familySignatures).forEach(([family, signature]) => {
      let score = 0;

      // Check pattern matches in strings
      signature.patterns.forEach((pattern) => {
        const patternMatches = strings.filter((str) => str.toLowerCase().includes(pattern)).length;
        score += patternMatches * 10;
      });

      if (score > 0) {
        matches[family] = score;
      }
    });

    // Find best match
    const bestMatch = Object.entries(matches).sort((a, b) => b[1] - a[1])[0];

    return bestMatch ? { family: bestMatch[0], confidence: Math.min(bestMatch[1], 100) } : null;
  }

  /**
   * Behavior-based classification
   */
  behaviorBasedClassification(sample) {
    const behaviors = [];

    // Analyze behavioral patterns
    if (sample.behavioral_analysis?.registry_operations?.length > 0) {
      behaviors.push('persistence');
    }

    if (sample.dynamic_analysis?.network_activity?.length > 0) {
      behaviors.push('c2_communication');
    }

    if (sample.behavioral_analysis?.dropped_files?.length > 0) {
      behaviors.push('payload_deployment');
    }

    if (sample.behavioral_analysis?.file_operations?.some((op) => op.operation === 'delete')) {
      behaviors.push('data_destruction');
    }

    // Match behaviors to families
    const matches = {};
    Object.entries(this.familySignatures).forEach(([family, signature]) => {
      const matchCount = signature.behaviors.filter((b) => behaviors.includes(b)).length;
      if (matchCount > 0) {
        matches[family] = (matchCount / signature.behaviors.length) * 100;
      }
    });

    const bestMatch = Object.entries(matches).sort((a, b) => b[1] - a[1])[0];
    return bestMatch ? { family: bestMatch[0], confidence: bestMatch[1] } : null;
  }

  /**
   * YARA rule-based classification
   */
  yaraBasedClassification(sample) {
    if (!sample.yara_matches || sample.yara_matches.length === 0) {
      return null;
    }

    // Use YARA matches for classification
    const familyTags = sample.yara_matches
      .flatMap((match) => match.tags || [])
      .filter((tag) => Object.keys(this.familySignatures).includes(tag));

    if (familyTags.length > 0) {
      return {
        family: familyTags[0],
        confidence: 90,
      };
    }

    return null;
  }

  /**
   * ML-based classification (simulated)
   */
  mlBasedClassification(sample) {
    // Simulate ML-based classification
    const features = {
      entropy: sample.static_analysis?.entropy || 0,
      imports_count: sample.static_analysis?.imports?.length || 0,
      strings_count: sample.static_analysis?.strings?.length || 0,
      packed: sample.static_analysis?.packer_detected ? 1 : 0,
      network_activity: sample.dynamic_analysis?.network_activity?.length || 0,
    };

    // Simple heuristic-based simulation
    if (features.entropy > 7.0 && features.network_activity > 0) {
      return { family: 'unknown', confidence: 60, type: 'trojan' };
    }

    return null;
  }

  /**
   * Aggregate classification results
   */
  aggregateResults(results) {
    const votes = {};
    let totalConfidence = 0;
    let voteCount = 0;

    // Collect votes from each classification method
    Object.values(results).forEach((result) => {
      if (result && result.family) {
        votes[result.family] = (votes[result.family] || 0) + result.confidence;
        totalConfidence += result.confidence;
        voteCount += 1;
      }
    });

    // Determine final classification
    if (Object.keys(votes).length === 0) {
      return {
        family: 'unknown',
        type: 'unknown',
        threat_level: 'medium',
        confidence: 0,
      };
    }

    const bestMatch = Object.entries(votes).sort((a, b) => b[1] - a[1])[0];
    const family = bestMatch[0];
    const confidence = Math.round(bestMatch[1] / voteCount);

    return {
      family,
      type: this.determineType(family),
      threat_level: this.determineThreatLevel(family, confidence),
      confidence,
    };
  }

  /**
   * Determine malware type from family
   */
  determineType(family) {
    const typeMap = {
      emotet: 'trojan',
      wannacry: 'ransomware',
      trickbot: 'trojan',
      ryuk: 'ransomware',
      zeus: 'trojan',
      unknown: 'unknown',
    };

    return typeMap[family] || 'other';
  }

  /**
   * Determine threat level
   */
  determineThreatLevel(family, confidence) {
    const highThreatFamilies = ['wannacry', 'ryuk', 'emotet'];

    if (highThreatFamilies.includes(family) && confidence > 70) {
      return 'critical';
    }

    if (confidence > 80) {
      return 'high';
    }

    if (confidence > 50) {
      return 'medium';
    }

    return 'low';
  }

  /**
   * Get classification for a sample
   */
  async getClassification(sampleId) {
    try {
      const sample = await MalwareSample.findOne({ id: sampleId });
      if (!sample) {
        throw new Error('Sample not found');
      }

      return {
        family: sample.malware_family,
        type: sample.classification,
        threat_level: sample.threat_level,
        confidence: sample.confidence_score,
      };
    } catch (error) {
      logger.error('Error getting classification:', error);
      throw error;
    }
  }

  /**
   * Manual classification override
   */
  async manualClassify(sampleId, classification) {
    try {
      const sample = await MalwareSample.findOne({ id: sampleId });
      if (!sample) {
        throw new Error('Sample not found');
      }

      sample.malware_family = classification.family;
      sample.classification = classification.type;
      sample.threat_level = classification.threat_level;
      sample.confidence_score = 100; // Manual classification has 100% confidence
      await sample.save();

      logger.info(`Manual classification applied: ${sampleId} -> ${classification.family}`);

      return sample;
    } catch (error) {
      logger.error('Error applying manual classification:', error);
      throw error;
    }
  }
}

module.exports = new ClassificationService();
