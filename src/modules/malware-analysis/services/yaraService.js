/**
 * YARA Rule Generation and Management Service
 */

const YaraRule = require('../models/YaraRule');
const MalwareSample = require('../models/MalwareSample');
const logger = require('../utils/logger');

class YaraService {
  /**
   * Generate YARA rule from a malware sample
   */
  async generateRule(sampleId, options = {}) {
    try {
      const sample = await MalwareSample.findOne({ id: sampleId });
      if (!sample) {
        throw new Error('Sample not found');
      }

      logger.info(`Generating YARA rule for sample: ${sampleId}`);

      // Extract unique strings for YARA rule
      const strings = this.selectUniqueStrings(sample.static_analysis?.strings || [], options);

      // Generate rule name
      const ruleName = options.rule_name || this.generateRuleName(sample);

      // Create rule structure
      const rule = {
        rule_name: ruleName,
        namespace: options.namespace || 'malware',
        tags: this.generateTags(sample),
        meta: {
          author: options.author || 'black-cross',
          description: options.description || `Rule for ${sample.file_name}`,
          reference: `sample:${sample.sha256}`,
          date: new Date().toISOString().split('T')[0],
          version: '1.0',
          malware_family: sample.malware_family || 'unknown',
          severity: sample.threat_level || 'medium',
        },
        strings_section: strings,
        condition: this.generateCondition(strings, options),
        rule_content: '',
        generated_from_sample: sampleId,
        created_by: options.created_by || 'system',
      };

      // Generate full rule content
      rule.rule_content = this.buildRuleContent(rule);

      // Save rule
      const yaraRule = new YaraRule(rule);
      await yaraRule.save();

      logger.info(`YARA rule generated: ${ruleName}`);

      return yaraRule;
    } catch (error) {
      logger.error('Error generating YARA rule:', error);
      throw error;
    }
  }

  /**
   * Select unique and characteristic strings
   */
  selectUniqueStrings(allStrings, options) {
    const maxStrings = options.max_strings || 20;
    const minLength = options.min_length || 8;

    // Filter strings
    const filtered = allStrings
      .filter((str) => str.length >= minLength)
      .filter((str) => !this.isCommonString(str))
      .slice(0, maxStrings);

    // Convert to YARA string format
    return filtered.map((str, index) => ({
      identifier: `$str${index + 1}`,
      type: 'text',
      value: str,
      modifiers: ['ascii', 'wide', 'nocase'],
    }));
  }

  /**
   * Check if string is too common to be useful
   */
  isCommonString(str) {
    const commonPatterns = [
      /^[0-9]+$/,
      /^[a-zA-Z]$/,
      /^(the|and|for|are|but|not|you|all|can|her|was|one|our|out|day|get)$/i,
      /^(http|https|ftp|file)$/i,
      /^(windows|system32|program files)$/i,
    ];

    return commonPatterns.some((pattern) => pattern.test(str));
  }

  /**
   * Generate rule name
   */
  generateRuleName(sample) {
    const family = sample.malware_family || 'unknown';
    const timestamp = Date.now().toString().slice(-6);
    return `${family}_${timestamp}`.replace(/[^a-zA-Z0-9_]/g, '_');
  }

  /**
   * Generate tags for rule
   */
  generateTags(sample) {
    const tags = [];

    if (sample.classification) {
      tags.push(sample.classification);
    }

    if (sample.malware_family) {
      tags.push(sample.malware_family);
    }

    if (sample.threat_level) {
      tags.push(sample.threat_level);
    }

    return tags;
  }

  /**
   * Generate condition for YARA rule
   */
  generateCondition(strings, options) {
    const threshold = options.threshold || Math.ceil(strings.length / 2);

    if (strings.length === 0) {
      return 'true';
    }

    if (strings.length === 1) {
      return strings[0].identifier;
    }

    return `${threshold} of them`;
  }

  /**
   * Build complete YARA rule content
   */
  buildRuleContent(rule) {
    let content = '';

    // Rule header
    content += `rule ${rule.rule_name}`;

    // Tags
    if (rule.tags && rule.tags.length > 0) {
      content += ` : ${rule.tags.join(' ')}`;
    }

    content += ' {\n';

    // Meta section
    content += '  meta:\n';
    Object.entries(rule.meta).forEach(([key, value]) => {
      content += `    ${key} = "${value}"\n`;
    });

    // Strings section
    if (rule.strings_section && rule.strings_section.length > 0) {
      content += '  strings:\n';
      rule.strings_section.forEach((str) => {
        const modifiers = str.modifiers && str.modifiers.length > 0
          ? ` ${str.modifiers.join(' ')}`
          : '';
        content += `    ${str.identifier} = "${str.value}"${modifiers}\n`;
      });
    }

    // Condition section
    content += '  condition:\n';
    content += `    ${rule.condition}\n`;

    content += '}\n';

    return content;
  }

  /**
   * Get all YARA rules
   */
  async getRules(filters = {}, page = 1, limit = 50) {
    try {
      const query = {};

      if (filters.status) {
        query.status = filters.status;
      }

      if (filters.malware_family) {
        query['meta.malware_family'] = filters.malware_family;
      }

      if (filters.namespace) {
        query.namespace = filters.namespace;
      }

      const skip = (page - 1) * limit;

      const [rules, total] = await Promise.all([
        YaraRule.find(query)
          .sort({ created_at: -1 })
          .skip(skip)
          .limit(limit)
          .lean(),
        YaraRule.countDocuments(query),
      ]);

      return {
        rules,
        pagination: {
          page,
          limit,
          total,
          total_pages: Math.ceil(total / limit),
        },
      };
    } catch (error) {
      logger.error('Error getting YARA rules:', error);
      throw error;
    }
  }

  /**
   * Get YARA rule by ID
   */
  async getRule(id) {
    try {
      const rule = await YaraRule.findOne({ id });
      if (!rule) {
        throw new Error('Rule not found');
      }
      return rule;
    } catch (error) {
      logger.error('Error getting YARA rule:', error);
      throw error;
    }
  }

  /**
   * Update YARA rule
   */
  async updateRule(id, updates) {
    try {
      const rule = await YaraRule.findOne({ id });
      if (!rule) {
        throw new Error('Rule not found');
      }

      // Save version history
      if (!rule.version_history) {
        rule.version_history = [];
      }

      rule.version_history.push({
        version: rule.meta.version,
        rule_content: rule.rule_content,
        updated_at: rule.updated_at,
        updated_by: updates.updated_by,
        change_notes: updates.change_notes || 'No notes provided',
      });

      // Update version
      const currentVersion = parseFloat(rule.meta.version);
      rule.meta.version = (currentVersion + 0.1).toFixed(1);

      // Apply updates
      Object.assign(rule, updates);

      await rule.save();

      logger.info(`YARA rule updated: ${id}`);
      return rule;
    } catch (error) {
      logger.error('Error updating YARA rule:', error);
      throw error;
    }
  }

  /**
   * Delete YARA rule
   */
  async deleteRule(id) {
    try {
      const rule = await YaraRule.findOneAndDelete({ id });
      if (!rule) {
        throw new Error('Rule not found');
      }

      logger.info(`YARA rule deleted: ${id}`);
      return { message: 'Rule deleted successfully' };
    } catch (error) {
      logger.error('Error deleting YARA rule:', error);
      throw error;
    }
  }

  /**
   * Test YARA rule against samples
   */
  async testRule(ruleId, sampleIds = []) {
    try {
      const rule = await YaraRule.findOne({ id: ruleId });
      if (!rule) {
        throw new Error('Rule not found');
      }

      logger.info(`Testing YARA rule: ${ruleId}`);

      // Simulate rule testing
      const results = {
        true_positives: 0,
        false_positives: 0,
        true_negatives: 0,
        false_negatives: 0,
      };

      // In production, this would actually run YARA against samples
      // For now, simulate with random results
      if (sampleIds.length > 0) {
        results.true_positives = Math.floor(sampleIds.length * 0.8);
        results.false_positives = Math.floor(sampleIds.length * 0.1);
        results.false_negatives = sampleIds.length - results.true_positives;
      }

      // Update rule with test results
      rule.test_results = results;
      rule.tested = true;
      await rule.save();

      logger.info(`YARA rule tested: ${ruleId}`);

      return {
        rule_id: ruleId,
        rule_name: rule.rule_name,
        test_results: results,
        accuracy: rule.accuracy,
      };
    } catch (error) {
      logger.error('Error testing YARA rule:', error);
      throw error;
    }
  }

  /**
   * Export YARA rules
   */
  async exportRules(filters = {}, format = 'text') {
    try {
      const result = await this.getRules(filters, 1, 1000);

      if (format === 'text') {
        return result.rules.map((rule) => rule.rule_content).join('\n\n');
      }

      if (format === 'json') {
        return JSON.stringify(result.rules, null, 2);
      }

      throw new Error(`Unsupported format: ${format}`);
    } catch (error) {
      logger.error('Error exporting YARA rules:', error);
      throw error;
    }
  }

  /**
   * Import YARA rules
   */
  async importRule(ruleContent, metadata = {}) {
    try {
      // Parse rule content (simplified)
      const ruleName = ruleContent.match(/rule\s+(\w+)/)?.[1] || 'imported_rule';

      const rule = new YaraRule({
        rule_name: ruleName,
        namespace: metadata.namespace || 'imported',
        tags: metadata.tags || [],
        meta: metadata.meta || {
          author: 'imported',
          description: 'Imported YARA rule',
          date: new Date().toISOString().split('T')[0],
          version: '1.0',
        },
        rule_content: ruleContent,
        condition: 'imported',
        created_by: metadata.created_by || 'import',
      });

      await rule.save();

      logger.info(`YARA rule imported: ${ruleName}`);
      return rule;
    } catch (error) {
      logger.error('Error importing YARA rule:', error);
      throw error;
    }
  }
}

module.exports = new YaraService();
