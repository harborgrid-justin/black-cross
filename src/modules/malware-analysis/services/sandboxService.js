/**
 * Sandbox Environment Management Service
 */

const SandboxEnvironment = require('../models/SandboxEnvironment');
const logger = require('../utils/logger');

class SandboxService {
  /**
   * Create a new sandbox environment
   */
  async createEnvironment(environmentData) {
    try {
      const environment = new SandboxEnvironment({
        name: environmentData.name,
        description: environmentData.description,
        os_type: environmentData.os_type,
        os_version: environmentData.os_version,
        architecture: environmentData.architecture || 'x64',
        vm_config: environmentData.vm_config || {
          cpu_cores: 2,
          memory_mb: 2048,
          disk_gb: 50,
          network_enabled: true,
          network_mode: 'simulated',
        },
        installed_software: environmentData.installed_software || [],
        template: environmentData.template || false,
        created_by: environmentData.created_by,
        tags: environmentData.tags || [],
      });

      await environment.save();

      logger.info(`Sandbox environment created: ${environment.id}`);

      return environment;
    } catch (error) {
      logger.error('Error creating sandbox environment:', error);
      throw error;
    }
  }

  /**
   * Get all sandbox environments
   */
  async getEnvironments(filters = {}, page = 1, limit = 50) {
    try {
      const query = {};

      if (filters.os_type) {
        query.os_type = filters.os_type;
      }

      if (filters.status) {
        query.status = filters.status;
      }

      if (filters.template !== undefined) {
        query.template = filters.template;
      }

      const skip = (page - 1) * limit;

      const [environments, total] = await Promise.all([
        SandboxEnvironment.find(query)
          .sort({ created_at: -1 })
          .skip(skip)
          .limit(limit)
          .lean(),
        SandboxEnvironment.countDocuments(query),
      ]);

      return {
        environments,
        pagination: {
          page,
          limit,
          total,
          total_pages: Math.ceil(total / limit),
        },
      };
    } catch (error) {
      logger.error('Error getting sandbox environments:', error);
      throw error;
    }
  }

  /**
   * Get environment by ID
   */
  async getEnvironmentById(id) {
    try {
      const environment = await SandboxEnvironment.findOne({ id });
      if (!environment) {
        throw new Error('Environment not found');
      }
      return environment;
    } catch (error) {
      logger.error('Error getting environment by ID:', error);
      throw error;
    }
  }

  /**
   * Update environment
   */
  async updateEnvironment(id, updates) {
    try {
      const environment = await SandboxEnvironment.findOneAndUpdate(
        { id },
        { ...updates, updated_at: Date.now() },
        { new: true },
      );

      if (!environment) {
        throw new Error('Environment not found');
      }

      logger.info(`Environment updated: ${id}`);
      return environment;
    } catch (error) {
      logger.error('Error updating environment:', error);
      throw error;
    }
  }

  /**
   * Delete environment
   */
  async deleteEnvironment(id) {
    try {
      const environment = await SandboxEnvironment.findOneAndDelete({ id });
      if (!environment) {
        throw new Error('Environment not found');
      }

      logger.info(`Environment deleted: ${id}`);
      return { message: 'Environment deleted successfully' };
    } catch (error) {
      logger.error('Error deleting environment:', error);
      throw error;
    }
  }

  /**
   * Update environment status
   */
  async updateStatus(id, status) {
    try {
      const environment = await SandboxEnvironment.findOneAndUpdate(
        { id },
        { status, updated_at: Date.now() },
        { new: true },
      );

      if (!environment) {
        throw new Error('Environment not found');
      }

      logger.info(`Environment status updated: ${id} -> ${status}`);
      return environment;
    } catch (error) {
      logger.error('Error updating environment status:', error);
      throw error;
    }
  }

  /**
   * Get available environments for analysis
   */
  async getAvailableEnvironments(osType = null) {
    try {
      const query = { status: 'active' };
      if (osType) {
        query.os_type = osType;
      }

      const environments = await SandboxEnvironment.find(query).sort({ execution_count: 1 });

      return environments;
    } catch (error) {
      logger.error('Error getting available environments:', error);
      throw error;
    }
  }

  /**
   * Reserve environment for analysis
   */
  async reserveEnvironment(id) {
    try {
      const environment = await SandboxEnvironment.findOne({ id });
      if (!environment) {
        throw new Error('Environment not found');
      }

      if (environment.status !== 'active') {
        throw new Error('Environment not available');
      }

      environment.execution_count += 1;
      environment.last_used = new Date();
      await environment.save();

      logger.info(`Environment reserved: ${id}`);
      return environment;
    } catch (error) {
      logger.error('Error reserving environment:', error);
      throw error;
    }
  }

  /**
   * Update resource usage
   */
  async updateResourceUsage(id, usage) {
    try {
      const environment = await SandboxEnvironment.findOneAndUpdate(
        { id },
        {
          resource_usage: {
            cpu_percent: usage.cpu_percent,
            memory_percent: usage.memory_percent,
            disk_percent: usage.disk_percent,
            last_updated: new Date(),
          },
        },
        { new: true },
      );

      if (!environment) {
        throw new Error('Environment not found');
      }

      return environment;
    } catch (error) {
      logger.error('Error updating resource usage:', error);
      throw error;
    }
  }

  /**
   * Create snapshot of environment
   */
  async createSnapshot(id) {
    try {
      const environment = await SandboxEnvironment.findOne({ id });
      if (!environment) {
        throw new Error('Environment not found');
      }

      // Simulate snapshot creation
      const snapshotId = `snapshot_${Date.now()}`;
      environment.snapshot_id = snapshotId;
      await environment.save();

      logger.info(`Snapshot created for environment ${id}: ${snapshotId}`);
      return { snapshot_id: snapshotId, environment };
    } catch (error) {
      logger.error('Error creating snapshot:', error);
      throw error;
    }
  }

  /**
   * Restore environment from snapshot
   */
  async restoreSnapshot(id) {
    try {
      const environment = await SandboxEnvironment.findOne({ id });
      if (!environment) {
        throw new Error('Environment not found');
      }

      if (!environment.snapshot_id) {
        throw new Error('No snapshot available');
      }

      logger.info(`Environment restored from snapshot: ${id}`);
      return { message: 'Environment restored successfully', environment };
    } catch (error) {
      logger.error('Error restoring snapshot:', error);
      throw error;
    }
  }

  /**
   * Get environment statistics
   */
  async getStats() {
    try {
      const [total, active, inactive, maintenance] = await Promise.all([
        SandboxEnvironment.countDocuments(),
        SandboxEnvironment.countDocuments({ status: 'active' }),
        SandboxEnvironment.countDocuments({ status: 'inactive' }),
        SandboxEnvironment.countDocuments({ status: 'maintenance' }),
      ]);

      return {
        total,
        active,
        inactive,
        maintenance,
        available: active,
      };
    } catch (error) {
      logger.error('Error getting environment stats:', error);
      throw error;
    }
  }
}

module.exports = new SandboxService();
