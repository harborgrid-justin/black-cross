/**
 * Behavioral Analysis Service
 * Analyzes malware behavior patterns
 */

const MalwareSample = require('../models/MalwareSample');
const logger = require('../utils/logger');

class BehavioralAnalysisService {
  /**
   * Perform behavioral analysis
   */
  async analyze(sampleId) {
    try {
      const sample = await MalwareSample.findOne({ id: sampleId });
      if (!sample) {
        throw new Error('Sample not found');
      }

      logger.info(`Starting behavioral analysis for sample: ${sampleId}`);

      // Generate behavioral analysis data
      const analysis = {
        file_operations: this.simulateFileOperations(),
        registry_operations: this.simulateRegistryOperations(),
        dropped_files: this.simulateDroppedFiles(),
        mutexes_created: this.simulateMutexes(),
        screenshots: [],
        timeline: this.generateTimeline(),
      };

      // Update sample with behavioral analysis
      sample.behavioral_analysis = analysis;
      await sample.save();

      logger.info(`Behavioral analysis completed for sample: ${sampleId}`);

      return analysis;
    } catch (error) {
      logger.error('Error performing behavioral analysis:', error);
      throw error;
    }
  }

  /**
   * Simulate file operations
   */
  simulateFileOperations() {
    const operations = [
      {
        operation: 'create',
        path: 'C:\\Users\\Admin\\AppData\\Local\\Temp\\malware.tmp',
        timestamp: new Date(),
      },
      {
        operation: 'write',
        path: 'C:\\Users\\Admin\\AppData\\Local\\Temp\\malware.tmp',
        timestamp: new Date(),
      },
      {
        operation: 'delete',
        path: 'C:\\Users\\Admin\\Desktop\\important.docx',
        timestamp: new Date(),
      },
      {
        operation: 'create',
        path: 'C:\\Windows\\System32\\malicious.dll',
        timestamp: new Date(),
      },
    ];

    return operations.slice(0, Math.floor(Math.random() * 4) + 1);
  }

  /**
   * Simulate registry operations
   */
  simulateRegistryOperations() {
    const operations = [
      {
        operation: 'set',
        key: 'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',
        value: 'Malware',
        timestamp: new Date(),
      },
      {
        operation: 'create',
        key: 'HKEY_CURRENT_USER\\Software\\Malware',
        value: 'C:\\malware.exe',
        timestamp: new Date(),
      },
      {
        operation: 'delete',
        key: 'HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\SecurityService',
        value: '',
        timestamp: new Date(),
      },
    ];

    return operations.slice(0, Math.floor(Math.random() * 3) + 1);
  }

  /**
   * Simulate dropped files
   */
  simulateDroppedFiles() {
    const files = [
      {
        file_name: 'payload.dll',
        path: 'C:\\Windows\\System32\\payload.dll',
        hash: 'a1b2c3d4e5f6789012345678901234567890abcd',
        size: 524288,
      },
      {
        file_name: 'config.dat',
        path: 'C:\\Users\\Admin\\AppData\\Roaming\\config.dat',
        hash: 'f6e5d4c3b2a1098765432109876543210fedcba9',
        size: 1024,
      },
    ];

    return files.slice(0, Math.floor(Math.random() * 2) + 1);
  }

  /**
   * Simulate mutex creation
   */
  simulateMutexes() {
    const mutexes = [
      'Global\\MalwareMutex_12345',
      'Local\\AntiDebugMutex',
      'Global\\SingleInstance_Malware',
    ];

    return mutexes.slice(0, Math.floor(Math.random() * 2) + 1);
  }

  /**
   * Generate execution timeline
   */
  generateTimeline() {
    const now = Date.now();
    return [
      { timestamp: new Date(now), event: 'Sample execution started' },
      { timestamp: new Date(now + 100), event: 'Process created: malware.exe' },
      { timestamp: new Date(now + 200), event: 'File created: malware.tmp' },
      { timestamp: new Date(now + 300), event: 'Registry key modified: Run' },
      { timestamp: new Date(now + 400), event: 'Network connection established: 203.0.113.45:80' },
      { timestamp: new Date(now + 500), event: 'File dropped: payload.dll' },
      { timestamp: new Date(now + 600), event: 'Mutex created: MalwareMutex_12345' },
      { timestamp: new Date(now + 700), event: 'Sample execution completed' },
    ];
  }

  /**
   * Get behavioral analysis results
   */
  async getAnalysis(sampleId) {
    try {
      const sample = await MalwareSample.findOne({ id: sampleId });
      if (!sample) {
        throw new Error('Sample not found');
      }

      if (!sample.behavioral_analysis) {
        throw new Error('Behavioral analysis not yet performed');
      }

      return sample.behavioral_analysis;
    } catch (error) {
      logger.error('Error getting behavioral analysis:', error);
      throw error;
    }
  }

  /**
   * Generate comprehensive behavior report
   */
  async generateReport(sampleId) {
    try {
      const sample = await MalwareSample.findOne({ id: sampleId });
      if (!sample) {
        throw new Error('Sample not found');
      }

      const report = {
        sample_id: sample.id,
        file_name: sample.file_name,
        sha256: sample.sha256,
        submitted_at: sample.submitted_at,
        analysis_completed_at: sample.updated_at,
        static_analysis: sample.static_analysis,
        dynamic_analysis: sample.dynamic_analysis,
        behavioral_analysis: sample.behavioral_analysis,
        classification: sample.classification,
        malware_family: sample.malware_family,
        threat_level: sample.threat_level,
        iocs: sample.iocs,
        summary: this.generateSummary(sample),
      };

      return report;
    } catch (error) {
      logger.error('Error generating report:', error);
      throw error;
    }
  }

  /**
   * Generate analysis summary
   */
  generateSummary(sample) {
    const summary = {
      key_findings: [],
      behaviors_detected: [],
      risk_assessment: 'medium',
    };

    // Analyze key findings
    if (sample.behavioral_analysis?.registry_operations?.length > 0) {
      summary.key_findings.push('Registry modifications detected');
      summary.behaviors_detected.push('Persistence mechanism');
    }

    if (sample.dynamic_analysis?.network_activity?.length > 0) {
      summary.key_findings.push('Network communication detected');
      summary.behaviors_detected.push('Command and control');
    }

    if (sample.behavioral_analysis?.dropped_files?.length > 0) {
      summary.key_findings.push('File dropping behavior detected');
      summary.behaviors_detected.push('Payload deployment');
    }

    if (sample.static_analysis?.packer_detected) {
      summary.key_findings.push('Packed executable detected');
      summary.behaviors_detected.push('Code obfuscation');
    }

    // Assess risk
    if (summary.behaviors_detected.length >= 3) {
      summary.risk_assessment = 'high';
    } else if (summary.behaviors_detected.length >= 2) {
      summary.risk_assessment = 'medium';
    } else {
      summary.risk_assessment = 'low';
    }

    return summary;
  }
}

module.exports = new BehavioralAnalysisService();
