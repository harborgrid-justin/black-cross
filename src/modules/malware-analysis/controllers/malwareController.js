/**
 * Malware Analysis Controller
 * Handles HTTP requests for malware analysis operations
 */

const submissionService = require('../services/submissionService');
const staticAnalysisService = require('../services/staticAnalysisService');
const dynamicAnalysisService = require('../services/dynamicAnalysisService');
const behavioralAnalysisService = require('../services/behavioralAnalysisService');
const classificationService = require('../services/classificationService');
const iocExtractionService = require('../services/iocExtractionService');
const yaraService = require('../services/yaraService');
const logger = require('../utils/logger');

class MalwareController {
  /**
   * Submit malware sample
   */
  async submitSample(req, res) {
    try {
      // eslint-disable-next-line camelcase
      const { file_data, metadata } = req.body;

      // eslint-disable-next-line camelcase
      if (!file_data) {
        return res.status(400).json({ error: 'File data is required' });
      }

      // Convert file data (assume base64 encoded or buffer)
      // eslint-disable-next-line camelcase
      const fileBuffer = Buffer.from(file_data, 'base64');

      const result = await submissionService.submitSample(fileBuffer, metadata || {});

      return res.status(result.duplicate ? 200 : 201).json(result);
    } catch (error) {
      logger.error('Error in submitSample:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Get all submissions
   */
  async getSubmissions(req, res) {
    try {
      const filters = {
        status: req.query.status,
        priority: req.query.priority,
        submitted_by: req.query.submitted_by,
        classification: req.query.classification,
        malware_family: req.query.malware_family,
      };

      const page = parseInt(req.query.page, 10) || 1;
      const limit = parseInt(req.query.limit, 10) || 50;

      const result = await submissionService.getSubmissions(filters, page, limit);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in getSubmissions:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Get submission by ID
   */
  async getSubmissionById(req, res) {
    try {
      const { id } = req.params;
      const sample = await submissionService.getSubmissionById(id);

      return res.status(200).json(sample);
    } catch (error) {
      logger.error('Error in getSubmissionById:', error);
      return res.status(404).json({ error: error.message });
    }
  }

  /**
   * Get queue statistics
   */
  async getQueueStats(req, res) {
    try {
      const stats = await submissionService.getQueueStats();
      return res.status(200).json(stats);
    } catch (error) {
      logger.error('Error in getQueueStats:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Perform static analysis
   */
  async performStaticAnalysis(req, res) {
    try {
      const { id } = req.params;
      // eslint-disable-next-line camelcase
      const { file_data } = req.body;

      // eslint-disable-next-line camelcase
      if (!file_data) {
        return res.status(400).json({ error: 'File data is required' });
      }

      // eslint-disable-next-line camelcase
      const fileBuffer = Buffer.from(file_data, 'base64');
      const result = await staticAnalysisService.analyze(id, fileBuffer);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in performStaticAnalysis:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Get static analysis results
   */
  async getStaticAnalysis(req, res) {
    try {
      const { id } = req.params;
      const result = await staticAnalysisService.getAnalysis(id);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in getStaticAnalysis:', error);
      return res.status(404).json({ error: error.message });
    }
  }

  /**
   * Perform dynamic analysis
   */
  async performDynamicAnalysis(req, res) {
    try {
      const { id } = req.params;
      // eslint-disable-next-line camelcase
      const { environment_id } = req.body;

      // eslint-disable-next-line camelcase
      const result = await dynamicAnalysisService.analyze(id, environment_id);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in performDynamicAnalysis:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Get dynamic analysis results
   */
  async getDynamicAnalysis(req, res) {
    try {
      const { id } = req.params;
      const result = await dynamicAnalysisService.getAnalysis(id);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in getDynamicAnalysis:', error);
      return res.status(404).json({ error: error.message });
    }
  }

  /**
   * Get behavioral analysis
   */
  async getBehavioralAnalysis(req, res) {
    try {
      const { id } = req.params;
      const result = await behavioralAnalysisService.getAnalysis(id);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in getBehavioralAnalysis:', error);
      return res.status(404).json({ error: error.message });
    }
  }

  /**
   * Generate comprehensive report
   */
  async generateReport(req, res) {
    try {
      const { id } = req.params;
      const report = await behavioralAnalysisService.generateReport(id);

      return res.status(200).json(report);
    } catch (error) {
      logger.error('Error in generateReport:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Classify malware sample
   */
  async classifySample(req, res) {
    try {
      // eslint-disable-next-line camelcase
      const { sample_id } = req.body;

      // eslint-disable-next-line camelcase
      if (!sample_id) {
        return res.status(400).json({ error: 'Sample ID is required' });
      }

      // eslint-disable-next-line camelcase
      const result = await classificationService.classify(sample_id);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in classifySample:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Get classification
   */
  async getClassification(req, res) {
    try {
      const { id } = req.params;
      const result = await classificationService.getClassification(id);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in getClassification:', error);
      return res.status(404).json({ error: error.message });
    }
  }

  /**
   * Manual classification override
   */
  async manualClassify(req, res) {
    try {
      const { id } = req.params;
      // eslint-disable-next-line camelcase
      const { family, type, threat_level } = req.body;

      // eslint-disable-next-line camelcase
      if (!family || !type || !threat_level) {
        return res.status(400).json({ error: 'Family, type, and threat_level are required' });
      }

      const result = await classificationService.manualClassify(id, {
        family,
        type,
        // eslint-disable-next-line camelcase
        threat_level,
      });

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in manualClassify:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Extract IOCs
   */
  async extractIOCs(req, res) {
    try {
      const { id } = req.params;
      const result = await iocExtractionService.extractIOCs(id);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in extractIOCs:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Get IOCs
   */
  async getIOCs(req, res) {
    try {
      const { id } = req.params;
      const filters = {
        type: req.query.type,
        min_confidence: req.query.min_confidence ? parseInt(req.query.min_confidence, 10) : undefined,
      };

      const result = await iocExtractionService.getIOCs(id, filters);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in getIOCs:', error);
      return res.status(404).json({ error: error.message });
    }
  }

  /**
   * Export IOCs
   */
  async exportIOCs(req, res) {
    try {
      const { id } = req.params;
      const format = req.query.format || 'json';

      const result = await iocExtractionService.exportIOCs(id, format);

      const contentTypes = {
        json: 'application/json',
        csv: 'text/csv',
        stix: 'application/json',
        misp: 'application/json',
      };

      res.setHeader('Content-Type', contentTypes[format] || 'text/plain');
      return res.status(200).send(result);
    } catch (error) {
      logger.error('Error in exportIOCs:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Search IOCs
   */
  async searchIOCs(req, res) {
    try {
      const { value, type } = req.query;

      if (!value) {
        return res.status(400).json({ error: 'Search value is required' });
      }

      const result = await iocExtractionService.searchIOCs(value, type);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in searchIOCs:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Generate YARA rule
   */
  async generateYaraRule(req, res) {
    try {
      const { id } = req.params;
      const options = req.body || {};

      const result = await yaraService.generateRule(id, options);

      return res.status(201).json(result);
    } catch (error) {
      logger.error('Error in generateYaraRule:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Get YARA rules
   */
  async getYaraRules(req, res) {
    try {
      const filters = {
        status: req.query.status,
        malware_family: req.query.malware_family,
        namespace: req.query.namespace,
      };

      const page = parseInt(req.query.page, 10) || 1;
      const limit = parseInt(req.query.limit, 10) || 50;

      const result = await yaraService.getRules(filters, page, limit);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in getYaraRules:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Get YARA rule by ID
   */
  async getYaraRule(req, res) {
    try {
      const { ruleId } = req.params;
      const result = await yaraService.getRule(ruleId);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in getYaraRule:', error);
      return res.status(404).json({ error: error.message });
    }
  }

  /**
   * Test YARA rule
   */
  async testYaraRule(req, res) {
    try {
      const { ruleId } = req.params;
      // eslint-disable-next-line camelcase
      const { sample_ids } = req.body;

      // eslint-disable-next-line camelcase
      const result = await yaraService.testRule(ruleId, sample_ids || []);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in testYaraRule:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Export YARA rules
   */
  async exportYaraRules(req, res) {
    try {
      const filters = {
        status: req.query.status,
        malware_family: req.query.malware_family,
      };

      const format = req.query.format || 'text';

      const result = await yaraService.exportRules(filters, format);

      const contentType = format === 'json' ? 'application/json' : 'text/plain';
      res.setHeader('Content-Type', contentType);

      return res.status(200).send(result);
    } catch (error) {
      logger.error('Error in exportYaraRules:', error);
      return res.status(500).json({ error: error.message });
    }
  }
}

module.exports = new MalwareController();
