/**
 * Sandbox Environment Controller
 * Handles HTTP requests for sandbox environment management
 */

const sandboxService = require('../services/sandboxService');
const logger = require('../utils/logger');

class SandboxController {
  /**
   * Create new sandbox environment
   */
  async createEnvironment(req, res) {
    try {
      const environment = await sandboxService.createEnvironment(req.body);
      return res.status(201).json(environment);
    } catch (error) {
      logger.error('Error in createEnvironment:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Get all sandbox environments
   */
  async getEnvironments(req, res) {
    try {
      const filters = {
        os_type: req.query.os_type,
        status: req.query.status,
        template: req.query.template !== undefined ? req.query.template === 'true' : undefined,
      };

      const page = parseInt(req.query.page, 10) || 1;
      const limit = parseInt(req.query.limit, 10) || 50;

      const result = await sandboxService.getEnvironments(filters, page, limit);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in getEnvironments:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Get environment by ID
   */
  async getEnvironmentById(req, res) {
    try {
      const { id } = req.params;
      const environment = await sandboxService.getEnvironmentById(id);

      return res.status(200).json(environment);
    } catch (error) {
      logger.error('Error in getEnvironmentById:', error);
      return res.status(404).json({ error: error.message });
    }
  }

  /**
   * Update environment
   */
  async updateEnvironment(req, res) {
    try {
      const { id } = req.params;
      const environment = await sandboxService.updateEnvironment(id, req.body);

      return res.status(200).json(environment);
    } catch (error) {
      logger.error('Error in updateEnvironment:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Delete environment
   */
  async deleteEnvironment(req, res) {
    try {
      const { id } = req.params;
      const result = await sandboxService.deleteEnvironment(id);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in deleteEnvironment:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Update environment status
   */
  async updateStatus(req, res) {
    try {
      const { id } = req.params;
      const { status } = req.body;

      if (!status) {
        return res.status(400).json({ error: 'Status is required' });
      }

      const environment = await sandboxService.updateStatus(id, status);

      return res.status(200).json(environment);
    } catch (error) {
      logger.error('Error in updateStatus:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Get available environments
   */
  async getAvailableEnvironments(req, res) {
    try {
      const osType = req.query.os_type;
      const environments = await sandboxService.getAvailableEnvironments(osType);

      return res.status(200).json({ environments, count: environments.length });
    } catch (error) {
      logger.error('Error in getAvailableEnvironments:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Reserve environment for analysis
   */
  async reserveEnvironment(req, res) {
    try {
      const { id } = req.params;
      const environment = await sandboxService.reserveEnvironment(id);

      return res.status(200).json(environment);
    } catch (error) {
      logger.error('Error in reserveEnvironment:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Update resource usage
   */
  async updateResourceUsage(req, res) {
    try {
      const { id } = req.params;
      // eslint-disable-next-line camelcase
      const { cpu_percent, memory_percent, disk_percent } = req.body;

      // eslint-disable-next-line camelcase
      if (cpu_percent === undefined || memory_percent === undefined || disk_percent === undefined) {
        return res.status(400).json({ error: 'CPU, memory, and disk usage percentages are required' });
      }

      const environment = await sandboxService.updateResourceUsage(id, {
        // eslint-disable-next-line camelcase
        cpu_percent,
        // eslint-disable-next-line camelcase
        memory_percent,
        // eslint-disable-next-line camelcase
        disk_percent,
      });

      return res.status(200).json(environment);
    } catch (error) {
      logger.error('Error in updateResourceUsage:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Create snapshot
   */
  async createSnapshot(req, res) {
    try {
      const { id } = req.params;
      // eslint-disable-next-line camelcase
      const { snapshot_name } = req.body;

      // eslint-disable-next-line camelcase
      const result = await sandboxService.createSnapshot(id, snapshot_name);

      return res.status(201).json(result);
    } catch (error) {
      logger.error('Error in createSnapshot:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Restore snapshot
   */
  async restoreSnapshot(req, res) {
    try {
      const { id } = req.params;
      const result = await sandboxService.restoreSnapshot(id);

      return res.status(200).json(result);
    } catch (error) {
      logger.error('Error in restoreSnapshot:', error);
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * Get environment statistics
   */
  async getStats(req, res) {
    try {
      const stats = await sandboxService.getStats();
      return res.status(200).json(stats);
    } catch (error) {
      logger.error('Error in getStats:', error);
      return res.status(500).json({ error: error.message });
    }
  }
}

module.exports = new SandboxController();
