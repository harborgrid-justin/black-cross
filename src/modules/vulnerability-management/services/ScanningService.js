/**
 * Scanning Service
 * 
 * Business logic for vulnerability scanning operations
 */

const { scanRepository, vulnerabilityRepository } = require('../repositories');
const { Vulnerability } = require('../models');

class ScanningService {
  /**
   * Initiate a new vulnerability scan
   */
  async initiateScan(scanData) {
    const scan = await scanRepository.create({
      ...scanData,
      status: 'pending'
    });

    // Simulate scan start (in real implementation, this would trigger actual scanner)
    setTimeout(() => this.executeScan(scan.id), 100);

    return scan;
  }

  /**
   * Execute scan (simulated)
   */
  async executeScan(scanId) {
    const scan = await scanRepository.findById(scanId);
    if (!scan) {
      return null;
    }

    scan.start();
    await scanRepository.update(scanId, scan);

    // Simulate scan execution and vulnerability discovery
    // In real implementation, this would call external scanner APIs
    const simulatedResults = await this.simulateScanExecution(scan);

    // Create vulnerability records from scan results
    const vulnerabilities = await this.processScanResults(scan.id, simulatedResults);

    // Complete the scan
    const severityCounts = this.calculateSeverityCounts(vulnerabilities);
    scan.complete({
      total: vulnerabilities.length,
      ...severityCounts
    });

    await scanRepository.update(scanId, scan);

    return scan;
  }

  /**
   * Simulate scan execution (placeholder for actual scanner integration)
   */
  async simulateScanExecution(scan) {
    // This is a simulation - in real implementation, integrate with:
    // - Nessus API
    // - Qualys API
    // - OpenVAS
    // - Custom scanners
    
    return [
      {
        title: 'SQL Injection Vulnerability',
        description: 'Application vulnerable to SQL injection attacks',
        severity: 'critical',
        cvss_score: 9.8,
        cve_id: 'CVE-2024-12345',
        affected_asset: scan.target_assets[0] || 'unknown'
      },
      {
        title: 'Outdated SSL/TLS Configuration',
        description: 'Server using outdated SSL/TLS protocols',
        severity: 'high',
        cvss_score: 7.5,
        cve_id: null,
        affected_asset: scan.target_assets[0] || 'unknown'
      }
    ];
  }

  /**
   * Process scan results and create vulnerabilities
   */
  async processScanResults(scanId, results) {
    const vulnerabilities = [];

    for (const result of results) {
      const vulnerability = await vulnerabilityRepository.create({
        ...result,
        scan_id: scanId,
        scanner_source: (await scanRepository.findById(scanId))?.scanner_type,
        status: 'open',
        affected_assets: [result.affected_asset]
      });

      vulnerabilities.push(vulnerability);
    }

    return vulnerabilities;
  }

  /**
   * Calculate severity counts
   */
  calculateSeverityCounts(vulnerabilities) {
    return {
      critical: vulnerabilities.filter(v => v.severity === 'critical').length,
      high: vulnerabilities.filter(v => v.severity === 'high').length,
      medium: vulnerabilities.filter(v => v.severity === 'medium').length,
      low: vulnerabilities.filter(v => v.severity === 'low').length,
      info: vulnerabilities.filter(v => v.severity === 'info').length
    };
  }

  /**
   * Get scan by ID
   */
  async getScan(scanId) {
    return await scanRepository.findById(scanId);
  }

  /**
   * List scans with filters
   */
  async listScans(filters = {}) {
    return await scanRepository.findAll(filters);
  }

  /**
   * Get scan results (vulnerabilities found by scan)
   */
  async getScanResults(scanId) {
    const scan = await scanRepository.findById(scanId);
    if (!scan) {
      return null;
    }

    const vulnerabilities = await vulnerabilityRepository.findAll({ scan_id: scanId });
    
    return {
      scan,
      vulnerabilities: vulnerabilities.data,
      summary: {
        total: vulnerabilities.total,
        by_severity: this.calculateSeverityCounts(vulnerabilities.data)
      }
    };
  }

  /**
   * Schedule recurring scan
   */
  async scheduleScan(scanData, schedulePattern) {
    return await scanRepository.create({
      ...scanData,
      scheduled: true,
      schedule_pattern: schedulePattern,
      next_scheduled_at: this.calculateNextScheduledTime(schedulePattern)
    });
  }

  /**
   * Calculate next scheduled time based on pattern
   */
  calculateNextScheduledTime(pattern) {
    const now = new Date();
    // Simple implementation - in real app, use cron patterns
    switch (pattern) {
      case 'daily':
        now.setDate(now.getDate() + 1);
        break;
      case 'weekly':
        now.setDate(now.getDate() + 7);
        break;
      case 'monthly':
        now.setMonth(now.getMonth() + 1);
        break;
      default:
        now.setDate(now.getDate() + 7);
    }
    return now;
  }

  /**
   * Get scan statistics
   */
  async getStatistics() {
    return await scanRepository.getStatistics();
  }

  /**
   * Cancel a scan
   */
  async cancelScan(scanId) {
    const scan = await scanRepository.findById(scanId);
    if (!scan) {
      return null;
    }

    if (scan.status === 'running' || scan.status === 'pending') {
      scan.status = 'cancelled';
      scan.completed_at = new Date();
      await scanRepository.update(scanId, scan);
    }

    return scan;
  }
}

module.exports = new ScanningService();
