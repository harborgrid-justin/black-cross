/**
 * Trend Analysis Service
 *
 * Business logic for vulnerability trend analysis
 */

const { vulnerabilityRepository, remediationRepository, scanRepository } = require('../repositories');

class TrendAnalysisService {
  /**
   * Get vulnerability trends over time
   */
  async getVulnerabilityTrends(period = '30d') {
    const periodDays = this.parsePeriod(period);
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - periodDays);

    const vulnerabilities = await vulnerabilityRepository.findAll({ limit: 10000 });

    // Group by date
    const trendData = this.groupByDate(
      vulnerabilities.data.filter((v) => new Date(v.discovered_at) >= startDate),
      'discovered_at',
      periodDays
    );

    return {
      period,
      trend_data: trendData,
      summary: this.calculateTrendSummary(trendData)
    };
  }

  /**
   * Get remediation velocity (rate of vulnerability remediation)
   */
  async getRemediationVelocity(period = '30d') {
    const periodDays = this.parsePeriod(period);
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - periodDays);

    const remediations = await remediationRepository.findAll({ limit: 10000 });
    const completed = remediations.data.filter((r) => r.status === 'completed'
      && r.completed_at
      && new Date(r.completed_at) >= startDate);

    const velocityData = this.groupByDate(completed, 'completed_at', periodDays);

    return {
      period,
      velocity_data: velocityData,
      average_per_day: (completed.length / periodDays).toFixed(2),
      total_remediated: completed.length
    };
  }

  /**
   * Get vulnerability aging analysis
   */
  async getAgingAnalysis() {
    const vulnerabilities = await vulnerabilityRepository.findAll({
      status: 'open',
      limit: 10000
    });

    const now = new Date();
    const agingBuckets = {
      '0-7days': 0,
      '8-30days': 0,
      '31-60days': 0,
      '61-90days': 0,
      '90+days': 0
    };

    const criticalAging = [];

    vulnerabilities.data.forEach((vuln) => {
      const daysSinceDiscovery = Math.ceil((now - new Date(vuln.discovered_at)) / (1000 * 60 * 60 * 24));

      if (daysSinceDiscovery <= 7) agingBuckets['0-7days']++;
      else if (daysSinceDiscovery <= 30) agingBuckets['8-30days']++;
      else if (daysSinceDiscovery <= 60) agingBuckets['31-60days']++;
      else if (daysSinceDiscovery <= 90) agingBuckets['61-90days']++;
      else {
        agingBuckets['90+days']++;
        if (vuln.severity === 'critical' || vuln.severity === 'high') {
          criticalAging.push({
            ...vuln.toJSON(),
            age_days: daysSinceDiscovery
          });
        }
      }
    });

    return {
      aging_buckets: agingBuckets,
      critical_aged_vulnerabilities: criticalAging.sort((a, b) => b.age_days - a.age_days),
      average_age_days: this.calculateAverageAge(vulnerabilities.data)
    };
  }

  /**
   * Get severity distribution trends
   */
  async getSeverityTrends(period = '90d') {
    const periodDays = this.parsePeriod(period);
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - periodDays);

    const vulnerabilities = await vulnerabilityRepository.findAll({ limit: 10000 });
    const filtered = vulnerabilities.data.filter((v) => new Date(v.discovered_at) >= startDate);

    const severityByDate = {};
    const dateRange = this.generateDateRange(startDate, new Date());

    dateRange.forEach((date) => {
      severityByDate[date] = {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0
      };
    });

    filtered.forEach((vuln) => {
      const date = new Date(vuln.discovered_at).toISOString().split('T')[0];
      if (severityByDate[date]) {
        severityByDate[date][vuln.severity]++;
      }
    });

    return {
      period,
      severity_trends: severityByDate
    };
  }

  /**
   * Get category-based trends
   */
  async getCategoryTrends(period = '30d') {
    const periodDays = this.parsePeriod(period);
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - periodDays);

    const vulnerabilities = await vulnerabilityRepository.findAll({ limit: 10000 });
    const filtered = vulnerabilities.data.filter((v) => new Date(v.discovered_at) >= startDate);

    // Group by tags/categories
    const categoryCount = {};
    filtered.forEach((vuln) => {
      vuln.tags.forEach((tag) => {
        categoryCount[tag] = (categoryCount[tag] || 0) + 1;
      });
    });

    const sortedCategories = Object.entries(categoryCount)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);

    return {
      period,
      top_categories: sortedCategories.map(([category, count]) => ({
        category,
        count
      }))
    };
  }

  /**
   * Get vulnerability lifecycle metrics
   */
  async getLifecycleMetrics() {
    const allVulnerabilities = await vulnerabilityRepository.findAll({ limit: 10000 });

    const lifecycle = {
      open: 0,
      in_progress: 0,
      remediated: 0,
      accepted_risk: 0,
      false_positive: 0,
      average_time_to_remediate: 0
    };

    let totalRemediationTime = 0;
    let remediatedCount = 0;

    allVulnerabilities.data.forEach((vuln) => {
      lifecycle[vuln.status]++;

      if (vuln.status === 'remediated' && vuln.remediated_at) {
        const timeToRemediate = (new Date(vuln.remediated_at) - new Date(vuln.discovered_at)) / (1000 * 60 * 60 * 24);
        totalRemediationTime += timeToRemediate;
        remediatedCount++;
      }
    });

    lifecycle.average_time_to_remediate = remediatedCount > 0
      ? (totalRemediationTime / remediatedCount).toFixed(2)
      : 0;

    return lifecycle;
  }

  /**
   * Get comparative analysis (current vs previous period)
   */
  async getComparativeAnalysis(period = '30d') {
    const periodDays = this.parsePeriod(period);

    const currentStart = new Date();
    currentStart.setDate(currentStart.getDate() - periodDays);

    const previousStart = new Date(currentStart);
    previousStart.setDate(previousStart.getDate() - periodDays);

    const allVulns = await vulnerabilityRepository.findAll({ limit: 10000 });

    const current = allVulns.data.filter((v) => new Date(v.discovered_at) >= currentStart);

    const previous = allVulns.data.filter((v) => new Date(v.discovered_at) >= previousStart
      && new Date(v.discovered_at) < currentStart);

    return {
      current_period: {
        total: current.length,
        critical: current.filter((v) => v.severity === 'critical').length,
        high: current.filter((v) => v.severity === 'high').length
      },
      previous_period: {
        total: previous.length,
        critical: previous.filter((v) => v.severity === 'critical').length,
        high: previous.filter((v) => v.severity === 'high').length
      },
      change: {
        total: current.length - previous.length,
        critical: current.filter((v) => v.severity === 'critical').length - previous.filter((v) => v.severity === 'critical').length,
        high: current.filter((v) => v.severity === 'high').length - previous.filter((v) => v.severity === 'high').length
      }
    };
  }

  /**
   * Get predictive analytics
   */
  async getPredictiveAnalytics() {
    const trends = await this.getVulnerabilityTrends('90d');
    const velocity = await this.getRemediationVelocity('90d');

    // Simple linear projection
    const discoveryRate = trends.summary.total_discovered / 90;
    const remediationRate = parseFloat(velocity.average_per_day);

    const projectedIn30Days = {
      new_vulnerabilities: Math.round(discoveryRate * 30),
      remediated_vulnerabilities: Math.round(remediationRate * 30),
      net_change: Math.round((discoveryRate - remediationRate) * 30)
    };

    return {
      current_discovery_rate: discoveryRate.toFixed(2),
      current_remediation_rate: remediationRate,
      projection_30_days: projectedIn30Days,
      recommendation: this.getRecommendation(discoveryRate, remediationRate)
    };
  }

  /**
   * Helper: Parse period string to days
   */
  parsePeriod(period) {
    const match = period.match(/(\d+)([dwmy])/);
    if (!match) return 30;

    const value = parseInt(match[1]);
    const unit = match[2];

    switch (unit) {
      case 'd': return value;
      case 'w': return value * 7;
      case 'm': return value * 30;
      case 'y': return value * 365;
      default: return 30;
    }
  }

  /**
   * Helper: Group data by date
   */
  groupByDate(items, dateField, days) {
    const grouped = {};
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    items.forEach((item) => {
      const date = new Date(item[dateField]).toISOString().split('T')[0];
      grouped[date] = (grouped[date] || 0) + 1;
    });

    return grouped;
  }

  /**
   * Helper: Calculate trend summary
   */
  calculateTrendSummary(trendData) {
    const values = Object.values(trendData);
    const total = values.reduce((sum, val) => sum + val, 0);
    const average = values.length > 0 ? total / values.length : 0;

    return {
      total_discovered: total,
      average_per_day: average.toFixed(2),
      peak_day: Object.entries(trendData).sort((a, b) => b[1] - a[1])[0]
    };
  }

  /**
   * Helper: Calculate average age
   */
  calculateAverageAge(vulnerabilities) {
    if (vulnerabilities.length === 0) return 0;

    const now = new Date();
    const totalAge = vulnerabilities.reduce((sum, vuln) => {
      const age = (now - new Date(vuln.discovered_at)) / (1000 * 60 * 60 * 24);
      return sum + age;
    }, 0);

    return (totalAge / vulnerabilities.length).toFixed(2);
  }

  /**
   * Helper: Generate date range
   */
  generateDateRange(startDate, endDate) {
    const dates = [];
    const current = new Date(startDate);

    while (current <= endDate) {
      dates.push(current.toISOString().split('T')[0]);
      current.setDate(current.getDate() + 1);
    }

    return dates;
  }

  /**
   * Helper: Get recommendation based on rates
   */
  getRecommendation(discoveryRate, remediationRate) {
    if (remediationRate > discoveryRate * 1.2) {
      return 'Remediation velocity is healthy - backlog is decreasing';
    } if (remediationRate > discoveryRate * 0.8) {
      return 'Remediation velocity is adequate - maintain current efforts';
    }
    return 'Remediation velocity needs improvement - backlog is growing';
  }
}

module.exports = new TrendAnalysisService();
