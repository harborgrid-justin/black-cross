/**
 * CVE Service
 * 
 * Business logic for CVE tracking and monitoring
 */

const { cveRepository, vulnerabilityRepository } = require('../repositories');

class CVEService {
  /**
   * Create or update CVE record
   */
  async createOrUpdateCVE(cveData) {
    // Check if CVE already exists
    const existing = await cveRepository.findByCVEId(cveData.cve_id);
    
    if (existing) {
      // Update existing CVE
      return await cveRepository.update(existing.id, {
        ...cveData,
        last_modified_date: new Date()
      });
    }
    
    // Create new CVE
    return await cveRepository.create(cveData);
  }

  /**
   * Get CVE by ID
   */
  async getCVE(id) {
    return await cveRepository.findById(id);
  }

  /**
   * Get CVE by CVE ID string
   */
  async getCVEByCVEId(cveId) {
    return await cveRepository.findByCVEId(cveId);
  }

  /**
   * List CVEs with filters
   */
  async listCVEs(filters = {}) {
    return await cveRepository.findAll(filters);
  }

  /**
   * Import CVEs from external source (e.g., NVD feed)
   */
  async importCVEFeed(cveList) {
    const imported = [];
    const errors = [];

    for (const cveData of cveList) {
      try {
        const cve = await this.createOrUpdateCVE(cveData);
        imported.push(cve);
      } catch (error) {
        errors.push({
          cve_id: cveData.cve_id,
          error: error.message
        });
      }
    }

    return {
      imported: imported.length,
      errors: errors.length,
      details: { imported, errors }
    };
  }

  /**
   * Get CVE impact assessment
   */
  async getCVEImpact(cveId) {
    const cve = await cveRepository.findByCVEId(cveId);
    if (!cve) {
      return null;
    }

    // Find all vulnerabilities associated with this CVE
    const vulnerabilities = await this.getVulnerabilitiesByCVE(cveId);

    // Calculate impact
    const affectedAssets = new Set();
    vulnerabilities.forEach(vuln => {
      vuln.affected_assets.forEach(asset => affectedAssets.add(asset));
    });

    return {
      cve,
      vulnerabilities_count: vulnerabilities.length,
      affected_assets_count: affectedAssets.size,
      affected_assets: Array.from(affectedAssets),
      impact_level: this.calculateImpactLevel(cve, vulnerabilities.length, affectedAssets.size)
    };
  }

  /**
   * Calculate impact level
   */
  calculateImpactLevel(cve, vulnCount, assetCount) {
    const cvssScore = cve.getCVSSScore();
    
    if (cve.exploit_available && cvssScore >= 7.0 && assetCount > 10) {
      return 'critical';
    } else if (cvssScore >= 7.0 && assetCount > 5) {
      return 'high';
    } else if (cvssScore >= 4.0 || assetCount > 3) {
      return 'medium';
    } else {
      return 'low';
    }
  }

  /**
   * Get vulnerabilities associated with a CVE
   */
  async getVulnerabilitiesByCVE(cveId) {
    const allVulns = await vulnerabilityRepository.findAll({ limit: 10000 });
    return allVulns.data.filter(v => v.cve_id === cveId);
  }

  /**
   * Mark CVE as trending
   */
  async markAsTrending(cveId, trending = true) {
    const cve = await cveRepository.findByCVEId(cveId);
    if (!cve) {
      return null;
    }

    return await cveRepository.update(cve.id, { trending });
  }

  /**
   * Get trending CVEs
   */
  async getTrendingCVEs() {
    return await cveRepository.findAll({ trending: true });
  }

  /**
   * Get critical CVEs
   */
  async getCriticalCVEs() {
    const allCVEs = await cveRepository.findAll({ limit: 10000 });
    return allCVEs.data.filter(cve => cve.isCritical());
  }

  /**
   * Get CVE statistics
   */
  async getStatistics() {
    const stats = await cveRepository.getStatistics();
    const criticalCVEs = await this.getCriticalCVEs();
    
    return {
      ...stats,
      critical_cves: criticalCVEs.length
    };
  }

  /**
   * Search CVEs
   */
  async searchCVEs(searchTerm) {
    const allCVEs = await cveRepository.findAll({ limit: 10000 });
    
    return allCVEs.data.filter(cve => 
      cve.cve_id.toLowerCase().includes(searchTerm.toLowerCase()) ||
      cve.description.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }

  /**
   * Monitor CVE for updates
   */
  async monitorCVE(cveId) {
    const cve = await cveRepository.findByCVEId(cveId);
    if (!cve) {
      return null;
    }

    // In real implementation, this would set up monitoring/notifications
    // For now, just return the CVE with monitoring flag
    return {
      cve,
      monitoring: true,
      last_checked: new Date()
    };
  }
}

module.exports = new CVEService();
