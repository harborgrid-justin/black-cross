/**
 * Remediation Service
 *
 * Business logic for remediation tracking and verification
 */

const { remediationRepository, vulnerabilityRepository, patchRepository } = require('../repositories');

class RemediationService {
  /**
   * Create remediation task
   */
  async createRemediation(remediationData) {
    // Validate vulnerability exists
    const vulnerability = await vulnerabilityRepository.findById(remediationData.vulnerability_id);
    if (!vulnerability) {
      throw new Error('Vulnerability not found');
    }

    // Calculate due date based on priority if not provided
    if (!remediationData.due_date) {
      remediationData.due_date = this.calculateDueDate(remediationData.priority || vulnerability.priority);
    }

    const remediation = await remediationRepository.create(remediationData);

    // Update vulnerability status
    if (vulnerability.status === 'open') {
      vulnerability.updateStatus('in_progress');
      await vulnerabilityRepository.update(vulnerability.id, vulnerability);
    }

    return remediation;
  }

  /**
   * Calculate due date based on priority
   */
  calculateDueDate(priority) {
    const now = new Date();
    const daysToAdd = {
      critical: 2,
      high: 7,
      medium: 30,
      low: 90
    };

    now.setDate(now.getDate() + (daysToAdd[priority] || 30));
    return now;
  }

  /**
   * Get remediation by ID
   */
  async getRemediation(remediationId) {
    const remediation = await remediationRepository.findById(remediationId);
    if (!remediation) {
      return null;
    }

    // Enrich with vulnerability details
    const vulnerability = await vulnerabilityRepository.findById(remediation.vulnerability_id);

    // Check for associated patch
    let patch = null;
    if (remediation.patch_id) {
      patch = await patchRepository.findById(remediation.patch_id);
    }

    return {
      remediation: remediation.toJSON(),
      vulnerability: vulnerability ? vulnerability.toJSON() : null,
      patch: patch ? patch.toJSON() : null
    };
  }

  /**
   * List remediations with filters
   */
  async listRemediations(filters = {}) {
    return await remediationRepository.findAll(filters);
  }

  /**
   * Start remediation
   */
  async startRemediation(remediationId, startedBy) {
    const remediation = await remediationRepository.findById(remediationId);
    if (!remediation) {
      throw new Error('Remediation not found');
    }

    remediation.start();
    if (startedBy && !remediation.assigned_to) {
      remediation.assigned_to = startedBy;
    }

    return await remediationRepository.update(remediationId, remediation);
  }

  /**
   * Complete remediation
   */
  async completeRemediation(remediationId, completionData = {}) {
    const remediation = await remediationRepository.findById(remediationId);
    if (!remediation) {
      throw new Error('Remediation not found');
    }

    remediation.complete(completionData.notes);
    if (completionData.actual_cost) {
      remediation.actual_cost = completionData.actual_cost;
    }

    const updated = await remediationRepository.update(remediationId, remediation);

    // Update vulnerability status if not risk accepted
    if (!remediation.risk_accepted) {
      const vulnerability = await vulnerabilityRepository.findById(remediation.vulnerability_id);
      if (vulnerability) {
        vulnerability.updateStatus('remediated');
        await vulnerabilityRepository.update(vulnerability.id, vulnerability);
      }
    }

    return updated;
  }

  /**
   * Verify remediation
   */
  async verifyRemediation(remediationId, verificationData) {
    const remediation = await remediationRepository.findById(remediationId);
    if (!remediation) {
      throw new Error('Remediation not found');
    }

    if (remediation.status !== 'completed') {
      throw new Error('Can only verify completed remediations');
    }

    remediation.verify(verificationData.method, verificationData.notes);
    return await remediationRepository.update(remediationId, remediation);
  }

  /**
   * Accept risk instead of remediating
   */
  async acceptRisk(remediationId, acceptanceData) {
    const remediation = await remediationRepository.findById(remediationId);
    if (!remediation) {
      throw new Error('Remediation not found');
    }

    remediation.acceptRisk(
      acceptanceData.reason,
      acceptanceData.accepted_by,
      acceptanceData.expires_at
    );

    const updated = await remediationRepository.update(remediationId, remediation);

    // Update vulnerability status
    const vulnerability = await vulnerabilityRepository.findById(remediation.vulnerability_id);
    if (vulnerability) {
      vulnerability.updateStatus('accepted_risk');
      await vulnerabilityRepository.update(vulnerability.id, vulnerability);
    }

    return updated;
  }

  /**
   * Get overdue remediations
   */
  async getOverdueRemediations() {
    const overdue = await remediationRepository.findOverdue();

    return {
      count: overdue.length,
      remediations: overdue.map((r) => ({
        ...r.toJSON(),
        days_overdue: Math.ceil((new Date() - new Date(r.due_date)) / (1000 * 60 * 60 * 24))
      }))
    };
  }

  /**
   * Get remediation metrics
   */
  async getMetrics() {
    const stats = await remediationRepository.getStatistics();
    const overdue = await this.getOverdueRemediations();

    // Calculate MTTR (Mean Time To Remediate)
    const completedRemediations = await remediationRepository.findAll({
      status: 'completed',
      limit: 10000
    });

    const mttr = completedRemediations.data.reduce((sum, r) => {
      const time = r.getTimeToRemediate();
      return sum + (time || 0);
    }, 0) / (completedRemediations.total || 1);

    return {
      ...stats,
      overdue_count: overdue.count,
      mttr_days: parseFloat(mttr.toFixed(2)),
      sla_compliance_rate: ((stats.sla_met / stats.total) * 100).toFixed(2)
    };
  }

  /**
   * Get remediation status report
   */
  async getStatusReport() {
    const stats = await this.getMetrics();
    const overdue = await this.getOverdueRemediations();

    return {
      summary: {
        total_remediations: stats.total,
        completed: stats.by_status.completed || 0,
        in_progress: stats.by_status.in_progress || 0,
        planned: stats.by_status.planned || 0,
        overdue: stats.overdue_count,
        mttr_days: stats.mttr_days,
        sla_compliance_rate: stats.sla_compliance_rate
      },
      by_status: stats.by_status,
      overdue_critical: overdue.remediations.filter((r) => r.priority === 'critical').length,
      overdue_high: overdue.remediations.filter((r) => r.priority === 'high').length
    };
  }

  /**
   * Assign remediation
   */
  async assignRemediation(remediationId, assignData) {
    const remediation = await remediationRepository.findById(remediationId);
    if (!remediation) {
      throw new Error('Remediation not found');
    }

    if (assignData.assigned_to) {
      remediation.assigned_to = assignData.assigned_to;
    }
    if (assignData.assigned_team) {
      remediation.assigned_team = assignData.assigned_team;
    }

    return await remediationRepository.update(remediationId, remediation);
  }

  /**
   * Get remediations by assignee
   */
  async getRemediationsByAssignee(assigneeId) {
    return await remediationRepository.findAll({
      assigned_to: assigneeId,
      limit: 1000
    });
  }

  /**
   * Schedule verification scan
   */
  async scheduleVerification(remediationId, scheduledDate) {
    const remediation = await remediationRepository.findById(remediationId);
    if (!remediation) {
      throw new Error('Remediation not found');
    }

    // In production, this would schedule an actual verification scan
    return {
      remediation_id: remediationId,
      verification_scheduled: true,
      scheduled_date: scheduledDate,
      message: 'Verification scan scheduled successfully'
    };
  }

  /**
   * Get remediation effectiveness
   */
  async getRemediationEffectiveness() {
    const completed = await remediationRepository.findAll({
      status: 'completed',
      limit: 10000
    });

    const verified = completed.data.filter((r) => r.verified).length;
    const withActualCost = completed.data.filter((r) => r.actual_cost).length;

    const avgCost = withActualCost > 0
      ? completed.data.reduce((sum, r) => sum + (r.actual_cost || 0), 0) / withActualCost
      : 0;

    return {
      total_completed: completed.total,
      verified_count: verified,
      verification_rate: ((verified / completed.total) * 100).toFixed(2),
      average_cost: avgCost.toFixed(2),
      sla_compliance: ((completed.data.filter((r) => r.sla_met).length / completed.total) * 100).toFixed(2)
    };
  }
}

module.exports = new RemediationService();
