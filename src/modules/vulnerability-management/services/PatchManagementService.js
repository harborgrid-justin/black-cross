/**
 * Patch Management Service
 * 
 * Business logic for patch management workflow
 */

const { patchRepository, vulnerabilityRepository, remediationRepository } = require('../repositories');

class PatchManagementService {
  /**
   * Create patch record
   */
  async createPatch(patchData) {
    return await patchRepository.create(patchData);
  }

  /**
   * Get patch by ID
   */
  async getPatch(patchId) {
    return await patchRepository.findById(patchId);
  }

  /**
   * List patches with filters
   */
  async listPatches(filters = {}) {
    return await patchRepository.findAll(filters);
  }

  /**
   * Get available patches for a vulnerability
   */
  async getPatchesForVulnerability(vulnerabilityId) {
    const vulnerability = await vulnerabilityRepository.findById(vulnerabilityId);
    if (!vulnerability) {
      return null;
    }

    // Find patches that address this vulnerability
    const allPatches = await patchRepository.findAll({ limit: 10000 });
    const relevantPatches = allPatches.data.filter(patch =>
      patch.addressed_vulnerabilities.includes(vulnerabilityId) ||
      (vulnerability.cve_id && patch.addressed_cves.includes(vulnerability.cve_id))
    );

    return {
      vulnerability,
      patches: relevantPatches,
      available_count: relevantPatches.filter(p => p.deployment_status === 'available').length
    };
  }

  /**
   * Get patches for specific CVEs
   */
  async getPatchesForCVEs(cveIds) {
    return await patchRepository.findByCVEs(cveIds);
  }

  /**
   * Test patch
   */
  async testPatch(patchId, testingNotes) {
    const patch = await patchRepository.findById(patchId);
    if (!patch) {
      throw new Error('Patch not found');
    }

    patch.updateDeploymentStatus('testing', testingNotes);
    return await patchRepository.update(patchId, patch);
  }

  /**
   * Mark patch as tested
   */
  async markAsTested(patchId, testingNotes) {
    const patch = await patchRepository.findById(patchId);
    if (!patch) {
      throw new Error('Patch not found');
    }

    patch.markAsTested(testingNotes);
    return await patchRepository.update(patchId, patch);
  }

  /**
   * Approve patch for deployment
   */
  async approvePatch(patchId) {
    const patch = await patchRepository.findById(patchId);
    if (!patch) {
      throw new Error('Patch not found');
    }

    if (!patch.tested) {
      throw new Error('Patch must be tested before approval');
    }

    patch.updateDeploymentStatus('approved');
    return await patchRepository.update(patchId, patch);
  }

  /**
   * Deploy patch
   */
  async deployPatch(patchId, deploymentData) {
    const patch = await patchRepository.findById(patchId);
    if (!patch) {
      throw new Error('Patch not found');
    }

    if (patch.deployment_status !== 'approved' && patch.deployment_status !== 'available') {
      throw new Error('Patch must be approved before deployment');
    }

    // Update patch status
    patch.updateDeploymentStatus('deployed', deploymentData.notes);
    await patchRepository.update(patchId, patch);

    // Create remediation records for affected vulnerabilities
    const remediations = [];
    for (const vulnId of patch.addressed_vulnerabilities) {
      const remediation = await remediationRepository.create({
        vulnerability_id: vulnId,
        title: `Patch deployment: ${patch.name}`,
        description: `Deployed patch ${patch.name} to address vulnerability`,
        remediation_type: 'patch',
        status: 'completed',
        patch_id: patchId,
        assigned_to: deploymentData.deployed_by,
        started_at: new Date(),
        completed_at: new Date()
      });
      remediations.push(remediation);

      // Update vulnerability status
      const vuln = await vulnerabilityRepository.findById(vulnId);
      if (vuln) {
        vuln.updateStatus('remediated');
        await vulnerabilityRepository.update(vulnId, vuln);
      }
    }

    return {
      patch,
      remediations,
      deployment_timestamp: new Date()
    };
  }

  /**
   * Rollback patch
   */
  async rollbackPatch(patchId, reason) {
    const patch = await patchRepository.findById(patchId);
    if (!patch) {
      throw new Error('Patch not found');
    }

    if (!patch.rollback_available) {
      throw new Error('Rollback not available for this patch');
    }

    patch.updateDeploymentStatus('failed', `Rolled back: ${reason}`);
    await patchRepository.update(patchId, patch);

    // Revert vulnerability statuses
    for (const vulnId of patch.addressed_vulnerabilities) {
      const vuln = await vulnerabilityRepository.findById(vulnId);
      if (vuln && vuln.status === 'remediated') {
        vuln.updateStatus('open');
        await vulnerabilityRepository.update(vulnId, vuln);
      }
    }

    return patch;
  }

  /**
   * Get patch deployment schedule
   */
  async getDeploymentSchedule(filters = {}) {
    const approvedPatches = await patchRepository.findAll({
      deployment_status: 'approved',
      ...filters
    });

    // Sort by priority
    const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
    approvedPatches.data.sort((a, b) => 
      (priorityOrder[b.deployment_priority] || 0) - (priorityOrder[a.deployment_priority] || 0)
    );

    return {
      scheduled_patches: approvedPatches.data,
      total: approvedPatches.total,
      by_priority: {
        critical: approvedPatches.data.filter(p => p.deployment_priority === 'critical').length,
        high: approvedPatches.data.filter(p => p.deployment_priority === 'high').length,
        medium: approvedPatches.data.filter(p => p.deployment_priority === 'medium').length,
        low: approvedPatches.data.filter(p => p.deployment_priority === 'low').length
      }
    };
  }

  /**
   * Get patch compliance report
   */
  async getComplianceReport() {
    const allPatches = await patchRepository.findAll({ limit: 10000 });
    const stats = await patchRepository.getStatistics();

    return {
      total_patches: allPatches.total,
      deployed: stats.by_deployment_status.deployed || 0,
      pending_deployment: (stats.by_deployment_status.approved || 0) + (stats.by_deployment_status.available || 0),
      in_testing: stats.by_deployment_status.testing || 0,
      failed: stats.by_deployment_status.failed || 0,
      compliance_rate: ((stats.by_deployment_status.deployed || 0) / allPatches.total * 100).toFixed(2),
      requires_reboot: stats.requires_reboot
    };
  }

  /**
   * Get patch statistics
   */
  async getStatistics() {
    return await patchRepository.getStatistics();
  }

  /**
   * Get critical patches requiring immediate deployment
   */
  async getCriticalPatches() {
    const patches = await patchRepository.findAll({ 
      deployment_priority: 'critical',
      limit: 100 
    });

    return patches.data.filter(p => 
      p.deployment_status === 'available' || p.deployment_status === 'approved'
    );
  }
}

module.exports = new PatchManagementService();
