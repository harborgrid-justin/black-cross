/**
 * Asset Mapping Service
 * 
 * Business logic for asset-vulnerability mapping
 */

const { assetMappingRepository, vulnerabilityRepository } = require('../repositories');

class AssetMappingService {
  /**
   * Create asset-vulnerability mapping
   */
  async createMapping(mappingData) {
    // Validate vulnerability exists
    const vulnerability = await vulnerabilityRepository.findById(mappingData.vulnerability_id);
    if (!vulnerability) {
      throw new Error('Vulnerability not found');
    }

    // Create mapping
    const mapping = await assetMappingRepository.create(mappingData);

    // Update vulnerability's affected_assets list
    if (!vulnerability.affected_assets.includes(mappingData.asset_id)) {
      vulnerability.affected_assets.push(mappingData.asset_id);
      await vulnerabilityRepository.update(vulnerability.id, vulnerability);
    }

    return mapping;
  }

  /**
   * Get mappings for an asset
   */
  async getAssetVulnerabilities(assetId, filters = {}) {
    const mappings = await assetMappingRepository.findByAssetId(assetId);
    
    // Get detailed vulnerability information
    const vulnerabilities = [];
    for (const mapping of mappings) {
      const vuln = await vulnerabilityRepository.findById(mapping.vulnerability_id);
      if (vuln) {
        vulnerabilities.push({
          mapping,
          vulnerability: vuln
        });
      }
    }

    return {
      asset_id: assetId,
      total_vulnerabilities: vulnerabilities.length,
      vulnerabilities,
      summary: this.summarizeVulnerabilities(vulnerabilities)
    };
  }

  /**
   * Get assets affected by a vulnerability
   */
  async getVulnerabilityAssets(vulnerabilityId) {
    const mappings = await assetMappingRepository.findByVulnerabilityId(vulnerabilityId);
    
    return {
      vulnerability_id: vulnerabilityId,
      total_assets: mappings.length,
      assets: mappings.map(m => ({
        asset_id: m.asset_id,
        asset_name: m.asset_name,
        asset_type: m.asset_type,
        exposure_level: m.exposure_level,
        asset_criticality: m.asset_criticality,
        environment: m.environment,
        exposure_score: m.getExposureScore()
      }))
    };
  }

  /**
   * Summarize vulnerabilities
   */
  summarizeVulnerabilities(vulnerabilities) {
    const summary = {
      by_severity: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
      by_status: {},
      exploitable: 0,
      with_patches: 0
    };

    vulnerabilities.forEach(({ vulnerability }) => {
      summary.by_severity[vulnerability.severity]++;
      summary.by_status[vulnerability.status] = (summary.by_status[vulnerability.status] || 0) + 1;
      if (vulnerability.exploitable) summary.exploitable++;
      if (vulnerability.patch_available) summary.with_patches++;
    });

    return summary;
  }

  /**
   * Get vulnerability heat map
   */
  async getHeatMap(filters = {}) {
    return await assetMappingRepository.getHeatMapData();
  }

  /**
   * Get business unit impact
   */
  async getBusinessUnitImpact(businessUnit) {
    const mappings = await assetMappingRepository.findAll({ 
      business_unit: businessUnit,
      limit: 10000 
    });

    const criticalVulns = [];
    const highVulns = [];
    const affectedAssets = new Set();

    for (const mapping of mappings.data) {
      affectedAssets.add(mapping.asset_id);
      const vuln = await vulnerabilityRepository.findById(mapping.vulnerability_id);
      if (vuln) {
        if (vuln.severity === 'critical') criticalVulns.push(vuln);
        else if (vuln.severity === 'high') highVulns.push(vuln);
      }
    }

    return {
      business_unit: businessUnit,
      total_vulnerabilities: mappings.total,
      critical_count: criticalVulns.length,
      high_count: highVulns.length,
      affected_assets_count: affectedAssets.size,
      risk_level: this.calculateBusinessUnitRisk(criticalVulns.length, highVulns.length)
    };
  }

  /**
   * Calculate business unit risk level
   */
  calculateBusinessUnitRisk(criticalCount, highCount) {
    if (criticalCount > 5) return 'critical';
    if (criticalCount > 0 || highCount > 10) return 'high';
    if (highCount > 0) return 'medium';
    return 'low';
  }

  /**
   * Mark mapping as false positive
   */
  async markAsFalsePositive(mappingId, reason) {
    const mapping = await assetMappingRepository.findById(mappingId);
    if (!mapping) {
      throw new Error('Mapping not found');
    }

    mapping.markAsFalsePositive(reason);
    return await assetMappingRepository.update(mappingId, mapping);
  }

  /**
   * Update mapping detection
   */
  async updateDetection(mappingId) {
    const mapping = await assetMappingRepository.findById(mappingId);
    if (!mapping) {
      throw new Error('Mapping not found');
    }

    mapping.updateDetection();
    return await assetMappingRepository.update(mappingId, mapping);
  }

  /**
   * Get critical assets (assets with most critical vulnerabilities)
   */
  async getCriticalAssets(limit = 10) {
    const heatMap = await this.getHeatMap();
    
    return heatMap
      .filter(asset => asset.vulnerability_count > 0)
      .sort((a, b) => b.exposure_score - a.exposure_score)
      .slice(0, limit);
  }

  /**
   * Get mapping statistics
   */
  async getStatistics() {
    return await assetMappingRepository.getStatistics();
  }

  /**
   * Bulk create mappings
   */
  async bulkCreateMappings(mappingsData) {
    const created = [];
    const errors = [];

    for (const data of mappingsData) {
      try {
        const mapping = await this.createMapping(data);
        created.push(mapping);
      } catch (error) {
        errors.push({
          data,
          error: error.message
        });
      }
    }

    return {
      created: created.length,
      errors: errors.length,
      details: { created, errors }
    };
  }
}

module.exports = new AssetMappingService();
