/**
 * Prioritization Service
 * 
 * Business logic for risk-based vulnerability prioritization
 */

const { vulnerabilityRepository, assetMappingRepository, cveRepository } = require('../repositories');

class PrioritizationService {
  /**
   * Prioritize vulnerabilities based on multiple risk factors
   */
  async prioritizeVulnerabilities(options = {}) {
    const vulnerabilities = await vulnerabilityRepository.findAll({ limit: 10000 });
    
    const prioritized = [];
    
    for (const vuln of vulnerabilities.data) {
      // Calculate comprehensive risk score
      const riskFactors = await this.calculateRiskFactors(vuln);
      const priority = this.determinePriority(riskFactors);
      
      // Update vulnerability with new priority and risk score
      vuln.priority = priority;
      vuln.risk_score = riskFactors.total_risk_score;
      await vulnerabilityRepository.update(vuln.id, vuln);
      
      prioritized.push({
        ...vuln.toJSON(),
        risk_factors: riskFactors,
        recommended_action: this.getRecommendedAction(priority, riskFactors)
      });
    }
    
    // Sort by risk score descending
    prioritized.sort((a, b) => b.risk_score - a.risk_score);
    
    return {
      vulnerabilities: prioritized,
      summary: this.generatePrioritySummary(prioritized)
    };
  }

  /**
   * Calculate risk factors for a vulnerability
   */
  async calculateRiskFactors(vulnerability) {
    const factors = {
      cvss_score: vulnerability.cvss_score || 0,
      exploitability: 0,
      asset_criticality: 0,
      threat_intelligence: 0,
      business_context: 0,
      total_risk_score: 0
    };

    // CVSS score factor (40% weight)
    factors.cvss_score_weighted = (factors.cvss_score / 10) * 40;

    // Exploitability factor (30% weight)
    if (vulnerability.exploitable) {
      factors.exploitability = 30;
      
      // Check if CVE has exploit details
      if (vulnerability.cve_id) {
        const cve = await cveRepository.findByCVEId(vulnerability.cve_id);
        if (cve && cve.exploit_maturity === 'functional') {
          factors.exploitability += 10;
        } else if (cve && cve.exploit_maturity === 'high') {
          factors.exploitability += 20;
        }
      }
    }

    // Asset criticality factor (20% weight)
    const assetMappings = await assetMappingRepository.findByVulnerabilityId(vulnerability.id);
    if (assetMappings.length > 0) {
      const avgCriticality = assetMappings.reduce((sum, m) => sum + m.asset_criticality, 0) / assetMappings.length;
      factors.asset_criticality = (avgCriticality / 10) * 20;
      
      // Boost for external exposure
      const externalCount = assetMappings.filter(m => m.exposure_level === 'external').length;
      if (externalCount > 0) {
        factors.asset_criticality += 10;
      }
    }

    // Threat intelligence factor (10% weight)
    if (vulnerability.cve_id) {
      const cve = await cveRepository.findByCVEId(vulnerability.cve_id);
      if (cve) {
        if (cve.trending) factors.threat_intelligence += 5;
        if (cve.exploit_available) factors.threat_intelligence += 3;
        if (cve.epss_score && cve.epss_score > 0.5) factors.threat_intelligence += 2;
      }
    }

    // Business context (affected assets count)
    factors.business_context = Math.min(vulnerability.affected_assets.length * 2, 10);

    // Calculate total risk score
    factors.total_risk_score = (
      factors.cvss_score_weighted +
      factors.exploitability +
      factors.asset_criticality +
      factors.threat_intelligence +
      factors.business_context
    ).toFixed(2);

    return factors;
  }

  /**
   * Determine priority level based on risk factors
   */
  determinePriority(riskFactors) {
    const score = parseFloat(riskFactors.total_risk_score);
    
    if (score >= 80) return 'critical';
    if (score >= 60) return 'high';
    if (score >= 40) return 'medium';
    return 'low';
  }

  /**
   * Get recommended action based on priority and risk factors
   */
  getRecommendedAction(priority, riskFactors) {
    if (priority === 'critical') {
      return {
        action: 'immediate_remediation',
        timeframe: '24-48 hours',
        description: 'Requires immediate attention and remediation'
      };
    }
    
    if (priority === 'high') {
      if (riskFactors.exploitability > 30) {
        return {
          action: 'urgent_remediation',
          timeframe: '7 days',
          description: 'Exploit available - remediate urgently'
        };
      }
      return {
        action: 'prioritized_remediation',
        timeframe: '14 days',
        description: 'Schedule for priority remediation'
      };
    }
    
    if (priority === 'medium') {
      return {
        action: 'scheduled_remediation',
        timeframe: '30 days',
        description: 'Include in next patch cycle'
      };
    }
    
    return {
      action: 'monitor',
      timeframe: '90 days',
      description: 'Monitor and remediate as resources allow'
    };
  }

  /**
   * Generate priority summary
   */
  generatePrioritySummary(vulnerabilities) {
    return {
      total: vulnerabilities.length,
      by_priority: {
        critical: vulnerabilities.filter(v => v.priority === 'critical').length,
        high: vulnerabilities.filter(v => v.priority === 'high').length,
        medium: vulnerabilities.filter(v => v.priority === 'medium').length,
        low: vulnerabilities.filter(v => v.priority === 'low').length
      },
      requires_immediate_action: vulnerabilities.filter(v => 
        v.priority === 'critical' || 
        (v.priority === 'high' && v.risk_factors.exploitability > 30)
      ).length
    };
  }

  /**
   * Get priority list (top vulnerabilities)
   */
  async getPriorityList(limit = 50) {
    const vulnerabilities = await vulnerabilityRepository.findAll({
      status: 'open',
      limit: 10000
    });

    const prioritized = [];
    
    for (const vuln of vulnerabilities.data) {
      const riskFactors = await this.calculateRiskFactors(vuln);
      prioritized.push({
        ...vuln.toJSON(),
        risk_factors: riskFactors,
        recommended_action: this.getRecommendedAction(vuln.priority, riskFactors)
      });
    }

    prioritized.sort((a, b) => b.risk_score - a.risk_score);

    return prioritized.slice(0, limit);
  }

  /**
   * Re-prioritize all vulnerabilities
   */
  async reprioritize() {
    return await this.prioritizeVulnerabilities();
  }

  /**
   * Get prioritization rules
   */
  getPrioritizationRules() {
    return {
      factors: [
        {
          name: 'CVSS Score',
          weight: '40%',
          description: 'Base CVSS vulnerability score'
        },
        {
          name: 'Exploitability',
          weight: '30%',
          description: 'Whether exploit is available and its maturity level'
        },
        {
          name: 'Asset Criticality',
          weight: '20%',
          description: 'Criticality of affected assets and exposure level'
        },
        {
          name: 'Threat Intelligence',
          weight: '10%',
          description: 'Trending status, EPSS score, and threat activity'
        }
      ],
      priority_thresholds: {
        critical: 'â‰¥ 80',
        high: '60-79',
        medium: '40-59',
        low: '< 40'
      }
    };
  }

  /**
   * Apply custom prioritization rules
   */
  async applyCustomRules(customRules) {
    // Placeholder for custom rule application
    // In production, this would allow organizations to define custom prioritization logic
    return {
      applied: true,
      rules: customRules,
      message: 'Custom rules applied successfully'
    };
  }
}

module.exports = new PrioritizationService();
