/**
 * Vulnerability Repository
 *
 * Data access layer for vulnerability operations
 * In-memory storage for now, can be replaced with actual database implementation
 */

const { Vulnerability } = require('../models');

class VulnerabilityRepository {
  constructor() {
    this.vulnerabilities = new Map();
  }

  /**
   * Create a new vulnerability
   */
  async create(vulnerabilityData) {
    const vulnerability = new Vulnerability(vulnerabilityData);
    this.vulnerabilities.set(vulnerability.id, vulnerability);
    return vulnerability;
  }

  /**
   * Find vulnerability by ID
   */
  async findById(id) {
    return this.vulnerabilities.get(id) || null;
  }

  /**
   * Find vulnerability by CVE ID
   */
  async findByCVEId(cveId) {
    return Array.from(this.vulnerabilities.values()).find((v) => v.cve_id === cveId) || null;
  }

  /**
   * Find all vulnerabilities with optional filters
   */
  async findAll(filters = {}) {
    let results = Array.from(this.vulnerabilities.values());

    if (filters.status) {
      results = results.filter((v) => v.status === filters.status);
    }

    if (filters.severity) {
      results = results.filter((v) => v.severity === filters.severity);
    }

    if (filters.priority) {
      results = results.filter((v) => v.priority === filters.priority);
    }

    if (filters.exploitable !== undefined) {
      results = results.filter((v) => v.exploitable === filters.exploitable);
    }

    if (filters.scan_id) {
      results = results.filter((v) => v.scan_id === filters.scan_id);
    }

    if (filters.assigned_to) {
      results = results.filter((v) => v.assigned_to === filters.assigned_to);
    }

    // Sort by risk score descending by default
    results.sort((a, b) => b.risk_score - a.risk_score);

    // Pagination
    const page = filters.page || 1;
    const limit = filters.limit || 50;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;

    return {
      data: results.slice(startIndex, endIndex),
      total: results.length,
      page,
      limit,
      totalPages: Math.ceil(results.length / limit)
    };
  }

  /**
   * Update vulnerability
   */
  async update(id, updateData) {
    const vulnerability = this.vulnerabilities.get(id);
    if (!vulnerability) {
      return null;
    }

    Object.assign(vulnerability, updateData);
    vulnerability.updated_at = new Date();
    this.vulnerabilities.set(id, vulnerability);
    return vulnerability;
  }

  /**
   * Delete vulnerability
   */
  async delete(id) {
    return this.vulnerabilities.delete(id);
  }

  /**
   * Get vulnerability statistics
   */
  async getStatistics() {
    const vulnerabilities = Array.from(this.vulnerabilities.values());

    return {
      total: vulnerabilities.length,
      by_severity: {
        critical: vulnerabilities.filter((v) => v.severity === 'critical').length,
        high: vulnerabilities.filter((v) => v.severity === 'high').length,
        medium: vulnerabilities.filter((v) => v.severity === 'medium').length,
        low: vulnerabilities.filter((v) => v.severity === 'low').length,
        info: vulnerabilities.filter((v) => v.severity === 'info').length
      },
      by_status: {
        open: vulnerabilities.filter((v) => v.status === 'open').length,
        in_progress: vulnerabilities.filter((v) => v.status === 'in_progress').length,
        remediated: vulnerabilities.filter((v) => v.status === 'remediated').length,
        accepted_risk: vulnerabilities.filter((v) => v.status === 'accepted_risk').length,
        false_positive: vulnerabilities.filter((v) => v.status === 'false_positive').length
      },
      exploitable: vulnerabilities.filter((v) => v.exploitable).length,
      with_patches: vulnerabilities.filter((v) => v.patch_available).length
    };
  }

  /**
   * Get vulnerabilities by asset
   */
  async findByAsset(assetId) {
    const vulnerabilities = Array.from(this.vulnerabilities.values());
    return vulnerabilities.filter((v) => v.affected_assets.includes(assetId));
  }

  /**
   * Clear all data (for testing)
   */
  async clear() {
    this.vulnerabilities.clear();
  }
}

// Singleton instance
const vulnerabilityRepository = new VulnerabilityRepository();

module.exports = vulnerabilityRepository;
