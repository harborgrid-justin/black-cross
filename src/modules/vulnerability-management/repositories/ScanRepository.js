/**
 * Scan Repository
 * 
 * Data access layer for scan operations
 */

const { Scan } = require('../models');

class ScanRepository {
  constructor() {
    this.scans = new Map();
  }

  /**
   * Create a new scan
   */
  async create(scanData) {
    const scan = new Scan(scanData);
    this.scans.set(scan.id, scan);
    return scan;
  }

  /**
   * Find scan by ID
   */
  async findById(id) {
    return this.scans.get(id) || null;
  }

  /**
   * Find all scans with optional filters
   */
  async findAll(filters = {}) {
    let results = Array.from(this.scans.values());

    if (filters.status) {
      results = results.filter(s => s.status === filters.status);
    }

    if (filters.scanner_type) {
      results = results.filter(s => s.scanner_type === filters.scanner_type);
    }

    if (filters.scan_type) {
      results = results.filter(s => s.scan_type === filters.scan_type);
    }

    if (filters.created_by) {
      results = results.filter(s => s.created_by === filters.created_by);
    }

    // Sort by created_at descending by default
    results.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

    // Pagination
    const page = filters.page || 1;
    const limit = filters.limit || 50;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;

    return {
      data: results.slice(startIndex, endIndex),
      total: results.length,
      page,
      limit,
      totalPages: Math.ceil(results.length / limit)
    };
  }

  /**
   * Update scan
   */
  async update(id, updateData) {
    const scan = this.scans.get(id);
    if (!scan) {
      return null;
    }

    Object.assign(scan, updateData);
    scan.updated_at = new Date();
    this.scans.set(id, scan);
    return scan;
  }

  /**
   * Delete scan
   */
  async delete(id) {
    return this.scans.delete(id);
  }

  /**
   * Get scan statistics
   */
  async getStatistics() {
    const scans = Array.from(this.scans.values());
    
    return {
      total: scans.length,
      by_status: {
        pending: scans.filter(s => s.status === 'pending').length,
        running: scans.filter(s => s.status === 'running').length,
        completed: scans.filter(s => s.status === 'completed').length,
        failed: scans.filter(s => s.status === 'failed').length,
        cancelled: scans.filter(s => s.status === 'cancelled').length
      },
      scheduled: scans.filter(s => s.scheduled).length,
      total_vulnerabilities_found: scans.reduce((sum, s) => sum + s.vulnerabilities_found, 0)
    };
  }

  /**
   * Get scheduled scans
   */
  async findScheduled() {
    const scans = Array.from(this.scans.values());
    return scans.filter(s => s.scheduled && s.next_scheduled_at);
  }

  /**
   * Clear all data (for testing)
   */
  async clear() {
    this.scans.clear();
  }
}

// Singleton instance
const scanRepository = new ScanRepository();

module.exports = scanRepository;
