/**
 * Patch Repository
 *
 * Data access layer for patch operations
 */

const { Patch } = require('../models');

class PatchRepository {
  constructor() {
    this.patches = new Map();
  }

  /**
   * Create a new patch
   */
  async create(patchData) {
    const patch = new Patch(patchData);
    this.patches.set(patch.id, patch);
    return patch;
  }

  /**
   * Find patch by ID
   */
  async findById(id) {
    return this.patches.get(id) || null;
  }

  /**
   * Find patch by patch ID string
   */
  async findByPatchId(patchId) {
    return Array.from(this.patches.values()).find((p) => p.patch_id === patchId) || null;
  }

  /**
   * Find all patches with optional filters
   */
  async findAll(filters = {}) {
    let results = Array.from(this.patches.values());

    if (filters.severity) {
      results = results.filter((p) => p.severity === filters.severity);
    }

    if (filters.deployment_status) {
      results = results.filter((p) => p.deployment_status === filters.deployment_status);
    }

    if (filters.deployment_priority) {
      results = results.filter((p) => p.deployment_priority === filters.deployment_priority);
    }

    if (filters.vendor) {
      results = results.filter((p) => p.vendor.toLowerCase().includes(filters.vendor.toLowerCase()));
    }

    if (filters.product) {
      results = results.filter((p) => p.product.toLowerCase().includes(filters.product.toLowerCase()));
    }

    if (filters.tested !== undefined) {
      results = results.filter((p) => p.tested === filters.tested);
    }

    // Sort by release date descending by default
    results.sort((a, b) => new Date(b.release_date) - new Date(a.release_date));

    // Pagination
    const page = filters.page || 1;
    const limit = filters.limit || 50;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;

    return {
      data: results.slice(startIndex, endIndex),
      total: results.length,
      page,
      limit,
      totalPages: Math.ceil(results.length / limit)
    };
  }

  /**
   * Update patch
   */
  async update(id, updateData) {
    const patch = this.patches.get(id);
    if (!patch) {
      return null;
    }

    Object.assign(patch, updateData);
    patch.updated_at = new Date();
    this.patches.set(id, patch);
    return patch;
  }

  /**
   * Delete patch
   */
  async delete(id) {
    return this.patches.delete(id);
  }

  /**
   * Get patch statistics
   */
  async getStatistics() {
    const patches = Array.from(this.patches.values());

    return {
      total: patches.length,
      by_severity: {
        critical: patches.filter((p) => p.severity === 'critical').length,
        high: patches.filter((p) => p.severity === 'high').length,
        medium: patches.filter((p) => p.severity === 'medium').length,
        low: patches.filter((p) => p.severity === 'low').length
      },
      by_deployment_status: {
        available: patches.filter((p) => p.deployment_status === 'available').length,
        testing: patches.filter((p) => p.deployment_status === 'testing').length,
        approved: patches.filter((p) => p.deployment_status === 'approved').length,
        deployed: patches.filter((p) => p.deployment_status === 'deployed').length,
        failed: patches.filter((p) => p.deployment_status === 'failed').length
      },
      tested: patches.filter((p) => p.tested).length,
      requires_reboot: patches.filter((p) => p.requires_reboot).length
    };
  }

  /**
   * Find patches for specific CVEs
   */
  async findByCVEs(cveIds) {
    const patches = Array.from(this.patches.values());
    return patches.filter((p) => p.addressed_cves.some((cve) => cveIds.includes(cve)));
  }

  /**
   * Clear all data (for testing)
   */
  async clear() {
    this.patches.clear();
  }
}

// Singleton instance
const patchRepository = new PatchRepository();

module.exports = patchRepository;
