/**
 * Asset Mapping Repository
 * 
 * Data access layer for asset-vulnerability mapping operations
 */

const { AssetVulnerabilityMapping } = require('../models');

class AssetMappingRepository {
  constructor() {
    this.mappings = new Map();
  }

  /**
   * Create a new mapping
   */
  async create(mappingData) {
    const mapping = new AssetVulnerabilityMapping(mappingData);
    this.mappings.set(mapping.id, mapping);
    return mapping;
  }

  /**
   * Find mapping by ID
   */
  async findById(id) {
    return this.mappings.get(id) || null;
  }

  /**
   * Find mappings by asset ID
   */
  async findByAssetId(assetId) {
    const mappings = Array.from(this.mappings.values());
    return mappings.filter(m => m.asset_id === assetId);
  }

  /**
   * Find mappings by vulnerability ID
   */
  async findByVulnerabilityId(vulnerabilityId) {
    const mappings = Array.from(this.mappings.values());
    return mappings.filter(m => m.vulnerability_id === vulnerabilityId);
  }

  /**
   * Find all mappings with optional filters
   */
  async findAll(filters = {}) {
    let results = Array.from(this.mappings.values());

    if (filters.asset_id) {
      results = results.filter(m => m.asset_id === filters.asset_id);
    }

    if (filters.vulnerability_id) {
      results = results.filter(m => m.vulnerability_id === filters.vulnerability_id);
    }

    if (filters.asset_type) {
      results = results.filter(m => m.asset_type === filters.asset_type);
    }

    if (filters.exposure_level) {
      results = results.filter(m => m.exposure_level === filters.exposure_level);
    }

    if (filters.environment) {
      results = results.filter(m => m.environment === filters.environment);
    }

    if (filters.business_unit) {
      results = results.filter(m => m.business_unit === filters.business_unit);
    }

    if (filters.resolution_status) {
      results = results.filter(m => m.resolution_status === filters.resolution_status);
    }

    if (filters.false_positive !== undefined) {
      results = results.filter(m => m.false_positive === filters.false_positive);
    }

    if (filters.min_criticality) {
      results = results.filter(m => m.asset_criticality >= filters.min_criticality);
    }

    // Sort by exposure score descending
    results.sort((a, b) => b.getExposureScore() - a.getExposureScore());

    // Pagination
    const page = filters.page || 1;
    const limit = filters.limit || 50;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;

    return {
      data: results.slice(startIndex, endIndex),
      total: results.length,
      page,
      limit,
      totalPages: Math.ceil(results.length / limit)
    };
  }

  /**
   * Update mapping
   */
  async update(id, updateData) {
    const mapping = this.mappings.get(id);
    if (!mapping) {
      return null;
    }

    Object.assign(mapping, updateData);
    mapping.updated_at = new Date();
    this.mappings.set(id, mapping);
    return mapping;
  }

  /**
   * Delete mapping
   */
  async delete(id) {
    return this.mappings.delete(id);
  }

  /**
   * Get mapping statistics
   */
  async getStatistics() {
    const mappings = Array.from(this.mappings.values());
    
    return {
      total: mappings.length,
      by_asset_type: this.groupByField(mappings, 'asset_type'),
      by_exposure_level: {
        external: mappings.filter(m => m.exposure_level === 'external').length,
        internal: mappings.filter(m => m.exposure_level === 'internal').length,
        isolated: mappings.filter(m => m.exposure_level === 'isolated').length
      },
      by_environment: {
        production: mappings.filter(m => m.environment === 'production').length,
        staging: mappings.filter(m => m.environment === 'staging').length,
        development: mappings.filter(m => m.environment === 'development').length,
        test: mappings.filter(m => m.environment === 'test').length
      },
      by_resolution: {
        open: mappings.filter(m => m.resolution_status === 'open').length,
        in_progress: mappings.filter(m => m.resolution_status === 'in_progress').length,
        resolved: mappings.filter(m => m.resolution_status === 'resolved').length
      },
      false_positives: mappings.filter(m => m.false_positive).length
    };
  }

  /**
   * Helper method to group by field
   */
  groupByField(items, field) {
    const grouped = {};
    items.forEach(item => {
      const value = item[field] || 'unknown';
      grouped[value] = (grouped[value] || 0) + 1;
    });
    return grouped;
  }

  /**
   * Get asset vulnerability heat map data
   */
  async getHeatMapData() {
    const mappings = Array.from(this.mappings.values());
    const assetMap = new Map();

    mappings.forEach(mapping => {
      if (!assetMap.has(mapping.asset_id)) {
        assetMap.set(mapping.asset_id, {
          asset_id: mapping.asset_id,
          asset_name: mapping.asset_name,
          asset_type: mapping.asset_type,
          vulnerability_count: 0,
          exposure_score: 0
        });
      }
      
      const asset = assetMap.get(mapping.asset_id);
      asset.vulnerability_count++;
      asset.exposure_score = Math.max(asset.exposure_score, mapping.getExposureScore());
    });

    return Array.from(assetMap.values())
      .sort((a, b) => b.exposure_score - a.exposure_score);
  }

  /**
   * Clear all data (for testing)
   */
  async clear() {
    this.mappings.clear();
  }
}

// Singleton instance
const assetMappingRepository = new AssetMappingRepository();

module.exports = assetMappingRepository;
