/**
 * Remediation Repository
 *
 * Data access layer for remediation operations
 */

const { Remediation } = require('../models');

class RemediationRepository {
  constructor() {
    this.remediations = new Map();
  }

  /**
   * Create a new remediation
   */
  async create(remediationData) {
    const remediation = new Remediation(remediationData);
    this.remediations.set(remediation.id, remediation);
    return remediation;
  }

  /**
   * Find remediation by ID
   */
  async findById(id) {
    return this.remediations.get(id) || null;
  }

  /**
   * Find remediations by vulnerability ID
   */
  async findByVulnerabilityId(vulnerabilityId) {
    const remediations = Array.from(this.remediations.values());
    return remediations.filter((r) => r.vulnerability_id === vulnerabilityId);
  }

  /**
   * Find all remediations with optional filters
   */
  async findAll(filters = {}) {
    let results = Array.from(this.remediations.values());

    if (filters.status) {
      results = results.filter((r) => r.status === filters.status);
    }

    if (filters.priority) {
      results = results.filter((r) => r.priority === filters.priority);
    }

    if (filters.assigned_to) {
      results = results.filter((r) => r.assigned_to === filters.assigned_to);
    }

    if (filters.assigned_team) {
      results = results.filter((r) => r.assigned_team === filters.assigned_team);
    }

    if (filters.verified !== undefined) {
      results = results.filter((r) => r.verified === filters.verified);
    }

    if (filters.risk_accepted !== undefined) {
      results = results.filter((r) => r.risk_accepted === filters.risk_accepted);
    }

    if (filters.vulnerability_id) {
      results = results.filter((r) => r.vulnerability_id === filters.vulnerability_id);
    }

    // Sort by priority and due date
    results.sort((a, b) => {
      const priorityOrder = {
        critical: 4, high: 3, medium: 2, low: 1
      };
      const priorityDiff = (priorityOrder[b.priority] || 0) - (priorityOrder[a.priority] || 0);
      if (priorityDiff !== 0) return priorityDiff;

      if (a.due_date && b.due_date) {
        return new Date(a.due_date) - new Date(b.due_date);
      }
      return 0;
    });

    // Pagination
    const page = filters.page || 1;
    const limit = filters.limit || 50;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;

    return {
      data: results.slice(startIndex, endIndex),
      total: results.length,
      page,
      limit,
      totalPages: Math.ceil(results.length / limit)
    };
  }

  /**
   * Update remediation
   */
  async update(id, updateData) {
    const remediation = this.remediations.get(id);
    if (!remediation) {
      return null;
    }

    Object.assign(remediation, updateData);
    remediation.updated_at = new Date();
    this.remediations.set(id, remediation);
    return remediation;
  }

  /**
   * Delete remediation
   */
  async delete(id) {
    return this.remediations.delete(id);
  }

  /**
   * Get remediation statistics
   */
  async getStatistics() {
    const remediations = Array.from(this.remediations.values());

    const completedRemediations = remediations.filter((r) => r.status === 'completed');
    const totalTimeToRemediate = completedRemediations.reduce((sum, r) => {
      const time = r.getTimeToRemediate();
      return sum + (time || 0);
    }, 0);

    return {
      total: remediations.length,
      by_status: {
        planned: remediations.filter((r) => r.status === 'planned').length,
        in_progress: remediations.filter((r) => r.status === 'in_progress').length,
        testing: remediations.filter((r) => r.status === 'testing').length,
        completed: remediations.filter((r) => r.status === 'completed').length,
        failed: remediations.filter((r) => r.status === 'failed').length,
        cancelled: remediations.filter((r) => r.status === 'cancelled').length
      },
      verified: remediations.filter((r) => r.verified).length,
      risk_accepted: remediations.filter((r) => r.risk_accepted).length,
      sla_met: remediations.filter((r) => r.sla_met).length,
      sla_missed: remediations.filter((r) => !r.sla_met).length,
      average_time_to_remediate: completedRemediations.length > 0
        ? (totalTimeToRemediate / completedRemediations.length).toFixed(2)
        : 0
    };
  }

  /**
   * Get overdue remediations
   */
  async findOverdue() {
    const now = new Date();
    const remediations = Array.from(this.remediations.values());
    return remediations.filter((r) => r.due_date
      && new Date(r.due_date) < now
      && r.status !== 'completed'
      && r.status !== 'cancelled');
  }

  /**
   * Clear all data (for testing)
   */
  async clear() {
    this.remediations.clear();
  }
}

// Singleton instance
const remediationRepository = new RemediationRepository();

module.exports = remediationRepository;
