/**
 * CVE Repository
 *
 * Data access layer for CVE operations
 */

const { CVE } = require('../models');

class CVERepository {
  constructor() {
    this.cves = new Map();
  }

  /**
   * Create a new CVE
   */
  async create(cveData) {
    const cve = new CVE(cveData);
    this.cves.set(cve.id, cve);
    return cve;
  }

  /**
   * Find CVE by ID
   */
  async findById(id) {
    return this.cves.get(id) || null;
  }

  /**
   * Find CVE by CVE ID string
   */
  async findByCVEId(cveId) {
    return Array.from(this.cves.values()).find((c) => c.cve_id === cveId) || null;
  }

  /**
   * Find all CVEs with optional filters
   */
  async findAll(filters = {}) {
    let results = Array.from(this.cves.values());

    if (filters.severity) {
      results = results.filter((c) => c.severity === filters.severity);
    }

    if (filters.exploit_available !== undefined) {
      results = results.filter((c) => c.exploit_available === filters.exploit_available);
    }

    if (filters.trending !== undefined) {
      results = results.filter((c) => c.trending === filters.trending);
    }

    if (filters.min_cvss) {
      results = results.filter((c) => c.getCVSSScore() >= filters.min_cvss);
    }

    if (filters.published_after) {
      const afterDate = new Date(filters.published_after);
      results = results.filter((c) => c.published_date && new Date(c.published_date) >= afterDate);
    }

    // Sort by CVSS score descending by default
    results.sort((a, b) => b.getCVSSScore() - a.getCVSSScore());

    // Pagination
    const page = filters.page || 1;
    const limit = filters.limit || 50;
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;

    return {
      data: results.slice(startIndex, endIndex),
      total: results.length,
      page,
      limit,
      totalPages: Math.ceil(results.length / limit)
    };
  }

  /**
   * Update CVE
   */
  async update(id, updateData) {
    const cve = this.cves.get(id);
    if (!cve) {
      return null;
    }

    Object.assign(cve, updateData);
    cve.updated_at = new Date();
    this.cves.set(id, cve);
    return cve;
  }

  /**
   * Delete CVE
   */
  async delete(id) {
    return this.cves.delete(id);
  }

  /**
   * Get CVE statistics
   */
  async getStatistics() {
    const cves = Array.from(this.cves.values());

    return {
      total: cves.length,
      by_severity: {
        critical: cves.filter((c) => c.severity === 'critical').length,
        high: cves.filter((c) => c.severity === 'high').length,
        medium: cves.filter((c) => c.severity === 'medium').length,
        low: cves.filter((c) => c.severity === 'low').length
      },
      with_exploits: cves.filter((c) => c.exploit_available).length,
      with_patches: cves.filter((c) => c.patch_available).length,
      trending: cves.filter((c) => c.trending).length
    };
  }

  /**
   * Clear all data (for testing)
   */
  async clear() {
    this.cves.clear();
  }
}

// Singleton instance
const cveRepository = new CVERepository();

module.exports = cveRepository;
