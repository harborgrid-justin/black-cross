/**
 * Vulnerability Management Module
 *
 * Main entry point for the vulnerability management module
 * Comprehensive vulnerability lifecycle management from discovery to remediation
 */

const express = require('express');

const router = express.Router();
const services = require('./services');
const validators = require('./validators');
const VulnerabilityController = require('./controllers/VulnerabilityController');

// ==================== Module Health Check ====================

/**
 * Health check
 * GET /api/v1/vulnerabilities/health
 */
router.get('/health', (req, res) => {
  res.json({
    module: 'vulnerability-management',
    status: 'operational',
    version: '1.0.0',
    features: [
      'vulnerability-scanning',
      'cve-tracking',
      'asset-mapping',
      'patch-management',
      'risk-prioritization',
      'remediation-tracking',
      'trend-analysis'
    ],
    timestamp: new Date().toISOString()
  });
});

// ==================== Scanning Endpoints ====================

/**
 * Initiate vulnerability scan
 * POST /api/v1/vulnerabilities/scan
 */
router.post('/scan', async (req, res) => {
  try {
    const { error, value } = validators.scanSchemas.create.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const scan = await services.scanningService.initiateScan(value);
    res.status(201).json({
      success: true,
      data: scan.toJSON(),
      message: 'Scan initiated successfully'
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * List scans
 * GET /api/v1/vulnerabilities/scans
 */
router.get('/scans', async (req, res) => {
  try {
    const result = await services.scanningService.listScans(req.query);
    res.json({
      success: true,
      ...result
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Get scan details
 * GET /api/v1/vulnerabilities/scans/:id
 */
router.get('/scans/:id', async (req, res) => {
  try {
    const scan = await services.scanningService.getScan(req.params.id);
    if (!scan) {
      return res.status(404).json({ error: 'Scan not found' });
    }
    res.json({
      success: true,
      data: scan.toJSON()
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Get scan results
 * GET /api/v1/vulnerabilities/scans/:id/results
 */
router.get('/scans/:id/results', async (req, res) => {
  try {
    const results = await services.scanningService.getScanResults(req.params.id);
    if (!results) {
      return res.status(404).json({ error: 'Scan not found' });
    }
    res.json({
      success: true,
      data: results
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Schedule recurring scan
 * POST /api/v1/vulnerabilities/scan/schedule
 */
router.post('/scan/schedule', async (req, res) => {
  try {
    const { error, value } = validators.scanSchemas.schedule.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const scan = await services.scanningService.scheduleScan(value, value.schedule_pattern);
    res.status(201).json({
      success: true,
      data: scan.toJSON(),
      message: 'Scan scheduled successfully'
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ==================== CVE Endpoints ====================

/**
 * List CVEs
 * GET /api/v1/vulnerabilities/cves
 */
router.get('/cves', async (req, res) => {
  try {
    const result = await services.cveService.listCVEs(req.query);
    res.json({
      success: true,
      ...result
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Get CVE details
 * GET /api/v1/vulnerabilities/cves/:id
 */
router.get('/cves/:id', async (req, res) => {
  try {
    const cve = await services.cveService.getCVEByCVEId(req.params.id);
    if (!cve) {
      return res.status(404).json({ error: 'CVE not found' });
    }
    res.json({
      success: true,
      data: cve.toJSON()
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Get CVE impact assessment
 * GET /api/v1/vulnerabilities/cves/:id/impact
 */
router.get('/cves/:id/impact', async (req, res) => {
  try {
    const impact = await services.cveService.getCVEImpact(req.params.id);
    if (!impact) {
      return res.status(404).json({ error: 'CVE not found' });
    }
    res.json({
      success: true,
      data: impact
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Create or update CVE
 * POST /api/v1/vulnerabilities/cves
 */
router.post('/cves', async (req, res) => {
  try {
    const { error, value } = validators.cveSchemas.create.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const cve = await services.cveService.createOrUpdateCVE(value);
    res.status(201).json({
      success: true,
      data: cve.toJSON()
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ==================== Asset Mapping Endpoints ====================

/**
 * Get asset vulnerabilities
 * GET /api/v1/vulnerabilities/assets/:assetId
 */
router.get('/assets/:assetId', async (req, res) => {
  try {
    const result = await services.assetMappingService.getAssetVulnerabilities(req.params.assetId);
    res.json({
      success: true,
      data: result
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Create asset-vulnerability mapping
 * POST /api/v1/vulnerabilities/map
 */
router.post('/map', async (req, res) => {
  try {
    const { error, value } = validators.mappingSchemas.create.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const mapping = await services.assetMappingService.createMapping(value);
    res.status(201).json({
      success: true,
      data: mapping.toJSON()
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Get vulnerability heat map
 * GET /api/v1/vulnerabilities/heatmap
 */
router.get('/heatmap', async (req, res) => {
  try {
    const heatMap = await services.assetMappingService.getHeatMap();
    res.json({
      success: true,
      data: heatMap
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ==================== Patch Management Endpoints ====================

/**
 * List patches
 * GET /api/v1/vulnerabilities/patches
 */
router.get('/patches', async (req, res) => {
  try {
    const result = await services.patchManagementService.listPatches(req.query);
    res.json({
      success: true,
      ...result
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Create patch
 * POST /api/v1/vulnerabilities/patches
 */
router.post('/patches', async (req, res) => {
  try {
    const { error, value } = validators.patchSchemas.create.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const patch = await services.patchManagementService.createPatch(value);
    res.status(201).json({
      success: true,
      data: patch.toJSON()
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Deploy patch
 * POST /api/v1/vulnerabilities/patches/:id/deploy
 */
router.post('/patches/:id/deploy', async (req, res) => {
  try {
    const { error, value } = validators.patchSchemas.deploy.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const result = await services.patchManagementService.deployPatch(req.params.id, value);
    res.json({
      success: true,
      data: result,
      message: 'Patch deployed successfully'
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Test patch
 * POST /api/v1/vulnerabilities/patches/:id/test
 */
router.post('/patches/:id/test', async (req, res) => {
  try {
    const { error, value } = validators.patchSchemas.test.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const patch = await services.patchManagementService.testPatch(req.params.id, value.testing_notes);
    res.json({
      success: true,
      data: patch.toJSON(),
      message: 'Patch marked for testing'
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Approve patch
 * POST /api/v1/vulnerabilities/patches/:id/approve
 */
router.post('/patches/:id/approve', async (req, res) => {
  try {
    const patch = await services.patchManagementService.approvePatch(req.params.id);
    res.json({
      success: true,
      data: patch.toJSON(),
      message: 'Patch approved for deployment'
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ==================== Prioritization Endpoints ====================

/**
 * Prioritize vulnerabilities
 * POST /api/v1/vulnerabilities/prioritize
 */
router.post('/prioritize', async (req, res) => {
  try {
    const result = await services.prioritizationService.prioritizeVulnerabilities(req.body);
    res.json({
      success: true,
      data: result
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Get priority list
 * GET /api/v1/vulnerabilities/priority-list
 */
router.get('/priority-list', async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 50;
    const priorityList = await services.prioritizationService.getPriorityList(limit);
    res.json({
      success: true,
      data: priorityList
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Get prioritization rules
 * GET /api/v1/vulnerabilities/prioritization-rules
 */
router.get('/prioritization-rules', async (req, res) => {
  try {
    const rules = services.prioritizationService.getPrioritizationRules();
    res.json({
      success: true,
      data: rules
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ==================== Remediation Endpoints ====================

/**
 * Create remediation
 * POST /api/v1/vulnerabilities/:id/remediate
 */
router.post('/:id/remediate', async (req, res) => {
  try {
    const { error, value } = validators.remediationSchemas.create.validate({
      ...req.body,
      vulnerability_id: req.params.id
    });
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const remediation = await services.remediationService.createRemediation(value);
    res.status(201).json({
      success: true,
      data: remediation.toJSON(),
      message: 'Remediation task created'
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Get remediation metrics
 * GET /api/v1/vulnerabilities/remediations/metrics
 */
router.get('/remediations/metrics', async (req, res) => {
  try {
    const metrics = await services.remediationService.getMetrics();
    res.json({
      success: true,
      data: metrics
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * List remediations
 * GET /api/v1/vulnerabilities/remediations
 */
router.get('/remediations', async (req, res) => {
  try {
    const result = await services.remediationService.listRemediations(req.query);
    res.json({
      success: true,
      ...result
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Get remediation details
 * GET /api/v1/vulnerabilities/remediations/:id
 */
router.get('/remediations/:id', async (req, res) => {
  try {
    const remediation = await services.remediationService.getRemediation(req.params.id);
    if (!remediation) {
      return res.status(404).json({ error: 'Remediation not found' });
    }
    res.json({
      success: true,
      data: remediation
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Complete remediation
 * POST /api/v1/vulnerabilities/remediations/:id/complete
 */
router.post('/remediations/:id/complete', async (req, res) => {
  try {
    const { error, value } = validators.remediationSchemas.complete.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const remediation = await services.remediationService.completeRemediation(req.params.id, value);
    res.json({
      success: true,
      data: remediation.toJSON(),
      message: 'Remediation completed'
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Verify remediation
 * POST /api/v1/vulnerabilities/remediations/:id/verify
 */
router.post('/remediations/:id/verify', async (req, res) => {
  try {
    const { error, value } = validators.remediationSchemas.verify.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const remediation = await services.remediationService.verifyRemediation(req.params.id, value);
    res.json({
      success: true,
      data: remediation.toJSON(),
      message: 'Remediation verified'
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Get verification status
 * GET /api/v1/vulnerabilities/:id/verification
 */
router.get('/:id/verification', async (req, res) => {
  try {
    const { remediationRepository } = require('./repositories');
    const remediations = await remediationRepository.findByVulnerabilityId(req.params.id);

    const verificationStatus = {
      vulnerability_id: req.params.id,
      remediation_count: remediations.length,
      verified_count: remediations.filter((r) => r.verified).length,
      pending_verification: remediations.filter((r) => r.status === 'completed' && !r.verified).length,
      remediations: remediations.map((r) => ({
        id: r.id,
        status: r.status,
        verified: r.verified,
        verification_date: r.verification_date
      }))
    };

    res.json({
      success: true,
      data: verificationStatus
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ==================== Trend Analysis Endpoints ====================

/**
 * Get vulnerability trends
 * GET /api/v1/vulnerabilities/trends
 */
router.get('/trends', async (req, res) => {
  try {
    const period = req.query.period || '30d';
    const trends = await services.trendAnalysisService.getVulnerabilityTrends(period);
    res.json({
      success: true,
      data: trends
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/**
 * Get vulnerability analytics
 * GET /api/v1/vulnerabilities/analytics
 */
router.get('/analytics', async (req, res) => {
  try {
    const [
      aging,
      severity,
      lifecycle,
      velocity,
      predictive
    ] = await Promise.all([
      services.trendAnalysisService.getAgingAnalysis(),
      services.trendAnalysisService.getSeverityTrends(req.query.period || '90d'),
      services.trendAnalysisService.getLifecycleMetrics(),
      services.trendAnalysisService.getRemediationVelocity(req.query.period || '30d'),
      services.trendAnalysisService.getPredictiveAnalytics()
    ]);

    res.json({
      success: true,
      data: {
        aging,
        severity_trends: severity,
        lifecycle,
        velocity,
        predictive
      }
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ==================== Vulnerability CRUD Endpoints ====================

/**
 * Create vulnerability (manual)
 * POST /api/v1/vulnerabilities
 */
router.post('/', VulnerabilityController.create);

/**
 * Get vulnerability
 * GET /api/v1/vulnerabilities/:id
 */
router.get('/:id', VulnerabilityController.getById);

/**
 * List vulnerabilities
 * GET /api/v1/vulnerabilities
 */
router.get('/', VulnerabilityController.list);

/**
 * Update vulnerability
 * PATCH /api/v1/vulnerabilities/:id
 */
router.patch('/:id', VulnerabilityController.update);

/**
 * Delete vulnerability
 * DELETE /api/v1/vulnerabilities/:id
 */
router.delete('/:id', VulnerabilityController.delete);

module.exports = router;
