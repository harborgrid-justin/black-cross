/**
 * Example Vulnerability Controller
 * Demonstrates production-grade controller using Sequelize service pattern
 * 
 * This is a reference implementation showing best practices:
 * - Type-safe request/response handling
 * - Proper error handling with try-catch
 * - Input validation
 * - Consistent response format
 * - Pagination support
 * - Filter support
 */

import type { Request, Response } from 'express';
import { vulnerabilityService } from '../services';

export class VulnerabilityController {
  /**
   * Create a new vulnerability
   * POST /api/v1/vulnerabilities
   */
  async create(req: Request, res: Response): Promise<void> {
    try {
      // Validate required fields
      const { title, severity, affectedSystems, discoveredAt } = req.body;
      
      if (!title || !severity || !affectedSystems || !discoveredAt) {
        res.status(400).json({
          success: false,
          error: 'Missing required fields: title, severity, affectedSystems, discoveredAt',
        });
        return;
      }

      // Create vulnerability using service
      const vulnerability = await vulnerabilityService.create({
        title,
        severity,
        affectedSystems,
        discoveredAt: new Date(discoveredAt),
        cveId: req.body.cveId,
        description: req.body.description,
        cvssScore: req.body.cvssScore,
        publishedAt: req.body.publishedAt ? new Date(req.body.publishedAt) : undefined,
        status: req.body.status || 'open',
      });

      res.status(201).json({
        success: true,
        data: vulnerability,
      });
    } catch (error: any) {
      res.status(400).json({
        success: false,
        error: error.message || 'Failed to create vulnerability',
      });
    }
  }

  /**
   * Get vulnerability by ID
   * GET /api/v1/vulnerabilities/:id
   */
  async getById(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;

      const vulnerability = await vulnerabilityService.getById(id);

      res.json({
        success: true,
        data: vulnerability,
      });
    } catch (error: any) {
      if (error.message.includes('not found')) {
        res.status(404).json({
          success: false,
          error: 'Vulnerability not found',
        });
      } else {
        res.status(500).json({
          success: false,
          error: error.message || 'Failed to get vulnerability',
        });
      }
    }
  }

  /**
   * Get vulnerability by CVE ID
   * GET /api/v1/vulnerabilities/cve/:cveId
   */
  async getByCveId(req: Request, res: Response): Promise<void> {
    try {
      const { cveId } = req.params;

      const vulnerability = await vulnerabilityService.getByCveId(cveId);

      if (!vulnerability) {
        res.status(404).json({
          success: false,
          error: 'Vulnerability not found',
        });
        return;
      }

      res.json({
        success: true,
        data: vulnerability,
      });
    } catch (error: any) {
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to get vulnerability',
      });
    }
  }

  /**
   * List vulnerabilities with pagination and filters
   * GET /api/v1/vulnerabilities?page=1&pageSize=20&severity=critical&search=apache
   */
  async list(req: Request, res: Response): Promise<void> {
    try {
      const {
        page = '1',
        pageSize = '20',
        severity,
        status,
        search,
      } = req.query;

      // Build filters
      const filters: any = {
        page: parseInt(page as string, 10),
        pageSize: parseInt(pageSize as string, 10),
      };

      if (severity) {
        filters.severity = severity;
      }

      if (status) {
        filters.status = status;
      }

      if (search) {
        filters.search = search;
      }

      // Get paginated results
      const result = await vulnerabilityService.list(filters);

      res.json({
        success: true,
        ...result, // Includes: data, total, page, pageSize, totalPages, hasNext, hasPrev
      });
    } catch (error: any) {
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to list vulnerabilities',
      });
    }
  }

  /**
   * List vulnerabilities by severity
   * GET /api/v1/vulnerabilities/severity/:severity
   */
  async listBySeverity(req: Request, res: Response): Promise<void> {
    try {
      const { severity } = req.params;

      const vulnerabilities = await vulnerabilityService.listBySeverity(severity);

      res.json({
        success: true,
        data: vulnerabilities,
        total: vulnerabilities.length,
      });
    } catch (error: any) {
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to list vulnerabilities',
      });
    }
  }

  /**
   * List open vulnerabilities
   * GET /api/v1/vulnerabilities/open
   */
  async listOpen(req: Request, res: Response): Promise<void> {
    try {
      const vulnerabilities = await vulnerabilityService.listOpen();

      res.json({
        success: true,
        data: vulnerabilities,
        total: vulnerabilities.length,
      });
    } catch (error: any) {
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to list open vulnerabilities',
      });
    }
  }

  /**
   * List critical vulnerabilities
   * GET /api/v1/vulnerabilities/critical
   */
  async listCritical(req: Request, res: Response): Promise<void> {
    try {
      const vulnerabilities = await vulnerabilityService.listCritical();

      res.json({
        success: true,
        data: vulnerabilities,
        total: vulnerabilities.length,
      });
    } catch (error: any) {
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to list critical vulnerabilities',
      });
    }
  }

  /**
   * Update vulnerability
   * PUT /api/v1/vulnerabilities/:id
   */
  async update(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const updates = req.body;

      // Remove fields that shouldn't be updated directly
      delete updates.id;
      delete updates.createdAt;
      delete updates.updatedAt;

      const vulnerability = await vulnerabilityService.update(id, updates);

      res.json({
        success: true,
        data: vulnerability,
      });
    } catch (error: any) {
      if (error.message.includes('not found')) {
        res.status(404).json({
          success: false,
          error: 'Vulnerability not found',
        });
      } else {
        res.status(400).json({
          success: false,
          error: error.message || 'Failed to update vulnerability',
        });
      }
    }
  }

  /**
   * Update vulnerability status
   * PATCH /api/v1/vulnerabilities/:id/status
   */
  async updateStatus(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const { status } = req.body;

      if (!status) {
        res.status(400).json({
          success: false,
          error: 'Status is required',
        });
        return;
      }

      const vulnerability = await vulnerabilityService.updateStatus(id, status);

      res.json({
        success: true,
        data: vulnerability,
      });
    } catch (error: any) {
      if (error.message.includes('not found')) {
        res.status(404).json({
          success: false,
          error: 'Vulnerability not found',
        });
      } else {
        res.status(400).json({
          success: false,
          error: error.message || 'Failed to update status',
        });
      }
    }
  }

  /**
   * Mark vulnerability as patched
   * POST /api/v1/vulnerabilities/:id/patch
   */
  async patch(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;

      const vulnerability = await vulnerabilityService.patch(id);

      res.json({
        success: true,
        data: vulnerability,
      });
    } catch (error: any) {
      if (error.message.includes('not found')) {
        res.status(404).json({
          success: false,
          error: 'Vulnerability not found',
        });
      } else {
        res.status(400).json({
          success: false,
          error: error.message || 'Failed to patch vulnerability',
        });
      }
    }
  }

  /**
   * Delete vulnerability
   * DELETE /api/v1/vulnerabilities/:id
   */
  async delete(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;

      await vulnerabilityService.delete(id);

      res.json({
        success: true,
        message: 'Vulnerability deleted successfully',
      });
    } catch (error: any) {
      if (error.message.includes('not found')) {
        res.status(404).json({
          success: false,
          error: 'Vulnerability not found',
        });
      } else {
        res.status(500).json({
          success: false,
          error: error.message || 'Failed to delete vulnerability',
        });
      }
    }
  }

  /**
   * Get vulnerability statistics
   * GET /api/v1/vulnerabilities/stats
   */
  async getStatistics(req: Request, res: Response): Promise<void> {
    try {
      const stats = await vulnerabilityService.getStatistics();

      res.json({
        success: true,
        data: stats,
      });
    } catch (error: any) {
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to get statistics',
      });
    }
  }
}

// Export singleton instance
export const vulnerabilityController = new VulnerabilityController();
export default vulnerabilityController;
