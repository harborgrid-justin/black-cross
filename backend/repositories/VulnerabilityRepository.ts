/**
 * Vulnerability Repository
 * Type-safe repository for Vulnerability model operations
 */

import { Op } from 'sequelize';
import type { Vulnerability } from '../utils/sequelize';
import { BaseRepository } from '../utils/BaseRepository';
import VulnerabilityModel from '../models/Vulnerability';

class VulnerabilityRepository extends BaseRepository<Vulnerability> {
  protected model = VulnerabilityModel;

  /**
   * Find vulnerabilities by CVE ID
   */
  async findByCveId(cveId: string): Promise<Vulnerability | null> {
    return await this.model.findOne({
      where: { cveId },
    });
  }

  /**
   * Find vulnerabilities by severity
   */
  async findBySeverity(severity: string): Promise<Vulnerability[]> {
    return await this.model.findAll({
      where: { severity },
      order: [['cvssScore', 'DESC']],
    });
  }

  /**
   * Find vulnerabilities by status
   */
  async findByStatus(status: string): Promise<Vulnerability[]> {
    return await this.model.findAll({
      where: { status },
      order: [['discoveredAt', 'DESC']],
    });
  }

  /**
   * Find open vulnerabilities
   */
  async findOpen(): Promise<Vulnerability[]> {
    return await this.model.findAll({
      where: {
        status: {
          [Op.in]: ['open', 'in_progress'],
        },
      },
      order: [
        ['severity', 'ASC'],
        ['cvssScore', 'DESC'],
      ],
    });
  }

  /**
   * Find critical vulnerabilities
   */
  async findCritical(): Promise<Vulnerability[]> {
    return await this.model.findAll({
      where: {
        severity: 'critical',
        status: {
          [Op.notIn]: ['patched', 'mitigated'],
        },
      },
      order: [['discoveredAt', 'DESC']],
    });
  }

  /**
   * Find vulnerabilities by affected system
   */
  async findByAffectedSystem(systemId: string): Promise<Vulnerability[]> {
    return await this.model.findAll({
      where: {
        affectedSystems: {
          [Op.contains]: [systemId],
        },
      },
      order: [['severity', 'ASC']],
    });
  }

  /**
   * Update vulnerability status
   */
  async updateStatus(id: string, status: string): Promise<Vulnerability> {
    const data: any = { status };

    // If patching, set patchedAt
    if (status === 'patched') {
      data.patchedAt = new Date();
    }

    const vulnerability = await this.findByIdOrThrow(id);
    return await vulnerability.update(data);
  }

  /**
   * Get vulnerability statistics
   */
  async getStatistics(): Promise<{
    total: number;
    open: number;
    patched: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  }> {
    const [
      total,
      open,
      patched,
      critical,
      high,
      medium,
      low,
    ] = await Promise.all([
      this.count(),
      this.count({ status: { [Op.in]: ['open', 'in_progress'] } }),
      this.count({ status: { [Op.in]: ['patched', 'mitigated'] } }),
      this.count({ severity: 'critical' }),
      this.count({ severity: 'high' }),
      this.count({ severity: 'medium' }),
      this.count({ severity: 'low' }),
    ]);

    return {
      total, open, patched, critical, high, medium, low,
    };
  }

  /**
   * Build where clause with search support
   */
  protected override buildWhereClause(filters: any, search?: string): any {
    const where: any = { ...filters };

    if (search) {
      where[Op.or] = [
        { title: { [Op.iLike]: `%${search}%` } },
        { description: { [Op.iLike]: `%${search}%` } },
        { cveId: { [Op.iLike]: `%${search}%` } },
      ];
    }

    return where;
  }
}

// Export singleton instance
export const vulnerabilityRepository = new VulnerabilityRepository();
export default vulnerabilityRepository;
